<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>“互联网+”作品</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-03-06T10:47:47.491Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>孙涛&amp;占莹莹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>信号幽灵wifi（第四篇）</title>
    <link href="http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E5%9B%9B%E7%AF%87%EF%BC%89/</id>
    <published>2021-03-06T10:43:36.000Z</published>
    <updated>2021-03-06T10:47:47.491Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOCTL的调用逻辑"><a href="#IOCTL的调用逻辑" class="headerlink" title="IOCTL的调用逻辑"></a>IOCTL的调用逻辑</h1><p>之所以要分析这个，是因为上层wpa_supplicant和WIFI驱动打交道的方式，多半是通过ioctl的方式进行的，所以看看它的调用逻辑（这里只列出其主要的调用逻辑）：</p><p>       上面便是用户ioctl调用的流程图，它最终分为两条线即有两种支持，选择那一条或两条都选（个人感觉最好选第2条线，因为它最后也是会调用到相应的函数的，而且还有其它更多的命令支持），从实际的代码来看，如果dev-&gt;netdev_ops</p><p>-&gt;ndo_do_ioctl被初始化了，那么它一定会被调用，是否被初始化，在前面选择对net结构变量的初始化方式中有讨论过。</p><p>       下面来具体看看该调用流程，首先说明下，上面的流程主要实现在kernel/net/wireless/wext_core.c文件中，这是wireless的协议层实现，恰好我们在wpa_supplicant中通常选择的驱动类型也是wext，它的入口函数是wext_ioctl_dispatch：</p><p>/* entry point from dev ioctl*/</p><p>static int wext_ioctl_dispatch(struct net <em>net, struct ifreq</em>ifr,</p><p>                              unsigned int cmd, struct iw_request_info *info,</p><p>                              wext_ioctl_func standard,</p><p>                               wext_ioctl_funcprivate)</p><p>{<br>        int ret = wext_permission_check(cmd);</p><p> </p><p>        if (ret)</p><p>                return ret;</p><p> </p><p>        dev_load(net, ifr-&gt;ifr_name);</p><p>        rtnl_lock();</p><p>        ret = wireless_process_ioctl(net, ifr, cmd, info, standard,private);</p><p>        rtnl_unlock();</p><p> </p><p>        return ret;</p><p>}</p><p>      </p><p>它其实就是wireless_process_ioctl的封装函数，除了进行许可权限的确认，没有做什么其它内容，这里有standard和private两个函数指针的传递，其实就是两个回调函数，在后面会用到，它是由wext_handle_ioctl函数传递过来的：</p><p>int wext_handle_ioctl(structnet *net, struct ifreq *ifr, unsigned int cmd,</p><p>                      void __user *arg)</p><p>{<br>        struct iw_request_info info = { .cmd =cmd, .flags = 0 };</p><p>        int ret;</p><p> </p><p>        ret = wext_ioctl_dispatch(net, ifr, cmd, &amp;info,</p><p>                                 ioctl_standard_call,</p><p>                                 ioctl_private_call);     //这两个回调函数的定义之后再讨论，这里暂不理论</p><p>        if (ret &gt;= 0 &amp;&amp;</p><p>            IW_IS_GET(cmd) &amp;&amp;</p><p>            copy_to_user(arg, ifr, sizeof(structiwreq)))</p><p>                return -EFAULT;</p><p> </p><p>        return ret;</p><p>}</p><p>实际上传递的就是ioctl_standard_call和ioctl_private_call两个函数，在看看wireless_process_ioctl函数，这个函数很重要，下面做重点分析：</p><p>static intwireless_process_ioctl(struct net *net, struct ifreq *ifr,</p><p>                                  unsigned int cmd,</p><p>                                  structiw_request_info *info,</p><p>                                 wext_ioctl_func standard,</p><p>                                 wext_ioctl_func private)</p><p>{<br>        struct iwreq *iwr = (struct iwreq *)ifr;</p><p>        struct net_device *dev;</p><p>        iw_handler      handler;</p><p> </p><p>        /* Permissions are already checked indev_ioctl() before calling us.</p><p>         * The copy_to/from_user() of ifr isalso dealt with in there */</p><p> </p><p>        /* Make sure the device exist */</p><p>        if ((dev = __dev_get_by_name(net, ifr-&gt;ifr_name)) == NULL)             //通过网络接口名获取net_device设备</p><p>                return -ENODEV;</p><p> </p><p>        /* A bunch of special cases, then thegeneric case…</p><p>         * Note that ‘cmd’ is already filteredin dev_ioctl() with</p><p>         * (cmd &gt;= SIOCIWFIRST &amp;&amp;cmd &lt;= SIOCIWLAST) */</p><p>        if (cmd == SIOCGIWSTATS)</p><p>                returnstandard(dev, iwr, cmd, info,</p><p>                               &amp;iw_handler_get_iwstats);   //如果是状态查询命令，调用该函数（回调函数中的一个）</p><p> </p><p>#ifdef CONFIG_WEXT_PRIV</p><p>        if (cmd == SIOCGIWPRIV &amp;&amp; dev-&gt;wireless_handlers)</p><p>                returnstandard(dev, iwr, cmd, info,</p><p>                               iw_handler_get_private);      //如果是专有命令，调用回调函数，同上</p><p>#endif</p><p> </p><p>        /* Basic check */</p><p>        if (!netif_device_present(dev))</p><p>                return -ENODEV;</p><p> </p><p>        /* New driver API : try to find thehandler */</p><p>        handler = get_handler(dev, cmd);              //根据cmd参数，从dev成员中查询相应的处理函数</p><p>        if (handler) {<br>                /* Standard and private are notthe same */</p><p>                if (cmd &lt; SIOCIWFIRSTPRIV)</p><p>                        return standard(dev, iwr, cmd, info, handler);  //调用相应命令的处理函数</p><p>                else if (private)</p><p>                        return private(dev, iwr, cmd, info, handler);     //同上</p><p>        }</p><p>        /* Old driver API : call driver ioctlhandler */</p><p>        if(dev-&gt;netdev_ops-&gt;ndo_do_ioctl)</p><p>                return dev-&gt;netdev_ops-&gt;ndo_do_ioctl(dev,ifr, cmd);     //如果被设置就调用该函数</p><p>        return -EOPNOTSUPP;</p><p>}</p><p>该函数的大意是，通过网络接口名称获得一个网络设备，然后根据命令的类型调用相应的处理函数，特别的是当dev-&gt;netdev_ops-&gt;ndo_do_ioctl或dev-&gt;wireless_handlers被设置时，则会查找执行对应的处理函数。Get_handle函数用于查询处理函数使用：</p><p>static iw_handlerget_handler(struct net_device *dev, unsigned int cmd)</p><p>{<br>        /* Don’t “optimise” thefollowing variable, it will crash */</p><p>        unsigned int    index;          /* <em>MUST</em> be unsigned */</p><p>        const struct iw_handler_def *handlers = NULL;</p><p> </p><p>#ifdef CONFIG_CFG80211_WEXT</p><p>        if (dev-&gt;ieee80211_ptr &amp;&amp;dev-&gt;ieee80211_ptr-&gt;wiphy)</p><p>                handlers =dev-&gt;ieee80211_ptr-&gt;wiphy-&gt;wext;  //初始化默认的处理函数</p><p>#endif</p><p>#ifdef CONFIG_WIRELESS_EXT</p><p>        if (dev-&gt;wireless_handlers)</p><p>                handlers= dev-&gt;wireless_handlers;    //这里的dev-&gt;wireless_handlers在net初始化时被作为扩张功能选择性的设置，前面有提到过</p><p>#endif</p><p> </p><p>        if (!handlers)</p><p>                return NULL;</p><p> </p><p>        /* Try as a standard command */</p><p>        index = IW_IOCTL_IDX(cmd);</p><p>        if (index <handlers->num_standard)</p><p>                returnhandlers-&gt;standard[index];     //返回对应的标准函数</p><p> </p><p>#ifdef CONFIG_WEXT_PRIV</p><p>        /* Try as a private command */</p><p>        index = cmd - SIOCIWFIRSTPRIV;</p><p>        if (index <handlers->num_private)</p><p>                return handlers-&gt;private[index];        //返回对应的专有函数</p><p>#endif</p><p> </p><p>        /* Not found */</p><p>        return NULL;</p><p>}</p><p>那么这个dev-&gt;wireless_handlers究竟是什么，这里来揭开它的神秘面纱，在bcm4329源码src/wl/sys/wl_iw.c中，有它的定义：</p><p>static const iw_handler wl_iw_handler[]=</p><p>{<br>        (iw_handler) wl_iw_config_commit,</p><p>        (iw_handler) wl_iw_get_name,</p><p>        (iw_handler) NULL,</p><p>……</p><p>}</p><p> </p><p>static const iw_handler wl_iw_priv_handler[]= {<br>        NULL,</p><p>        (iw_handler)wl_iw_set_active_scan,</p><p>        NULL,</p><p>        (iw_handler)wl_iw_get_rssi,</p><p>……</p><p>}</p><p> </p><p>const struct iw_handler_def  wl_iw_handler_def =</p><p>{<br>        .num_standard =ARRAYSIZE(wl_iw_handler),</p><p>        .standard = (iw_handler *) wl_iw_handler,</p><p>        .num_private = ARRAYSIZE(wl_iw_priv_handler),</p><p>        .num_private_args =ARRAY_SIZE(wl_iw_priv_args),</p><p>        .private = (iw_handler *)wl_iw_priv_handler,</p><p>        .private_args = (void *)wl_iw_priv_args,</p><p> </p><p>#if WIRELESS_EXT &gt;= 19</p><p>        get_wireless_stats:dhd_get_wireless_stats,</p><p>#endif</p><p>        };</p><p>#endif</p><p>在net初始化的时候，这里把dev-&gt;wireless_handlers和dev-&gt;netdev_ops的初始化代码再贴出来：</p><p>int</p><p>dhd_net_attach(dhd_pub_t*dhdp, int ifidx)</p><p>{<br>……</p><p>#if (LINUX_VERSION_CODE &lt;KERNEL_VERSION(2, 6, 31))</p><p>        ASSERT(!net-&gt;open);</p><p>        net-&gt;get_stats = dhd_get_stats;</p><p>        net-&gt;do_ioctl =dhd_ioctl_entry;</p><p>       net-&gt;hard_start_xmit = dhd_start_xmit;</p><p>       net-&gt;set_mac_address = dhd_set_mac_address;</p><p>       net-&gt;set_multicast_list = dhd_set_multicast_list;</p><p>        net-&gt;open =net-&gt;stop = NULL;</p><p>#else</p><p>        ASSERT(!net-&gt;netdev_ops);</p><p>        net-&gt;netdev_ops = &amp;dhd_ops_virt;</p><p>#endif</p><p> </p><p>……</p><p>#if WIRELESS_EXT &gt; 12</p><p>        net-&gt;wireless_handlers = (struct iw_handler_def*)&amp;wl_iw_handler_def;   //这里的初始化工作很重要，之后的ioctl流程会涉及到对它的使用</p><p>#endif /* WIRELESS_EXT &gt; 12*/</p><p> </p><p> </p><p>……</p><p>}</p><p>看到这里，应该可以明白相应的命令最终会在wl_iw.c中被执行，这些处理函数也是在该文件中实现。上面已经获取了命令的处理函数，那么它是如何被执行的呢？这里wireless_process_ioctl里有standard和private的回调函数的调用：</p><p>static intioctl_standard_call(struct net_device *     dev,</p><p>                               structiwreq             *iwr,</p><p>                               unsigned int             cmd,</p><p>                               structiw_request_info   *info,</p><p>                               iw_handler               handler)</p><p>{<br>        const struct iw_ioctl_description*     descr;</p><p>        int                                     ret = -EINVAL;</p><p> </p><p>        /* Get the description of the IOCTL */</p><p>        if (IW_IOCTL_IDX(cmd) &gt;=standard_ioctl_num)</p><p>                return -EOPNOTSUPP;</p><p>        descr =&amp;(standard_ioctl[IW_IOCTL_IDX(cmd)]);</p><p> </p><p>        /* Check if we have a pointer to userspace data or not */</p><p>        if (descr-&gt;header_type !=IW_HEADER_TYPE_POINT) { </p><p>                /* No extra arguments. Trivialto handle */</p><p>                ret = handler(dev, info, &amp;(iwr-&gt;u),NULL);</p><p> </p><p>                /* Generate an event to notifylisteners of the change */</p><p>                if ((descr-&gt;flags &amp;IW_DESCR_FLAG_EVENT) &amp;&amp;</p><p>                   ((ret == 0) || (ret ==-EIWCOMMIT)))</p><p>                        wireless_send_event(dev, cmd, &amp;(iwr-&gt;u),NULL);</p><p>        } else {<br>                ret =ioctl_standard_iw_point(&amp;iwr-&gt;u.data, cmd, descr,</p><p>                                             handler, dev, info);</p><p>        }</p><p> </p><p>        /* Call commit handler if needed anddefined */</p><p>        if (ret == -EIWCOMMIT)</p><p>                ret =call_commit_handler(dev);</p><p> </p><p>        /* Here, we will generate theappropriate event if needed */</p><p> </p><p>        return ret;</p><p>}</p><p>回调函数中对传递过来的handler函数指针进行呼叫，对应的处理函数就会被执行，当然用户传送的命令还不止这些，所以才会有net-&gt;netdev_ops的存在的必要性。下面来就来看看执行到：</p><p>return dev-&gt;netdev_ops-&gt;ndo_do_ioctl(dev, ifr, cmd);     //wireless_process_ioctl的最后一句</p><p>就会调用dhd_ioctl函数，这是wlan驱动对ioctl调用的处理函数，就是根据用户传递过来的cmd，给它找一个最合适最合理的“归宿”。</p><p>static int</p><p>dhd_ioctl_entry(structnet_device *net, struct ifreq *ifr, int cmd)</p><p>{<br>……#ifdefined(CONFIG_WIRELESS_EXT)</p><p>        /* linux wireless extensions */</p><p>        if ((cmd &gt;= SIOCIWFIRST) &amp;&amp;(cmd &lt;= SIOCIWLAST)) {<br>                /* may recurse, do NOT lock */</p><p>                ret = wl_iw_ioctl(net, ifr, cmd);</p><p>               DHD_OS_WAKE_UNLOCK(&amp;dhd-&gt;pub);</p><p>                return ret;</p><p>        }</p><p>#endif /*defined(CONFIG_WIRELESS_EXT) */</p><p> </p><p>#if LINUX_VERSION_CODE &gt;KERNEL_VERSION(2, 4, 2)</p><p>        if (cmd == SIOCETHTOOL) {<br>                ret = dhd_ethtool(dhd,(void*)ifr-&gt;ifr_data);</p><p>               DHD_OS_WAKE_UNLOCK(&amp;dhd-&gt;pub);</p><p>                return ret;</p><p>        }</p><p>#endif /* LINUX_VERSION_CODE&gt; KERNEL_VERSION(2, 4, 2) */</p><p> </p><p>        if (cmd == SIOCDEVPRIVATE+1) {<br>                ret = wl_android_priv_cmd(net, ifr, cmd);</p><p>                dhd_check_hang(net,&amp;dhd-&gt;pub, ret);</p><p>                DHD_OS_WAKE_UNLOCK(&amp;dhd-&gt;pub);</p><p>                return ret;</p><p>        }</p><p> </p><p>        if (cmd != SIOCDEVPRIVATE) {<br>               DHD_OS_WAKE_UNLOCK(&amp;dhd-&gt;pub);</p><p>                return -EOPNOTSUPP;</p><p>        }</p><p> </p><p>        memset(&amp;ioc, 0, sizeof(ioc));</p><p>……</p><p>bcmerror = dhd_wl_ioctl(&amp;dhd-&gt;pub, ifidx, (wl_ioctl_t*)&amp;ioc, buf, buflen);</p><p>……</p><p>}</p><p>限于篇幅，该函数处理过程不再详述，大致的命令处理方法相似，wl_iw.c中的系列处理函数只是其中的一部分，wl_android中和dhd_linux.c也有相应的处理函数。</p><h1 id="数据的传送"><a href="#数据的传送" class="headerlink" title="数据的传送"></a>数据的传送</h1><ul><li>数据传送过程简述<br>传送指的是通过一个网络连接发送一个报文的行为.。无论何时内核需要传送一个数据报文, 它都必须调用驱动的 hard_start_xmit 方法将数据放在外出队列上。</li></ul><p>每个内核处理的报文都包含在一个 socket缓存结构( 结构 sk_buff )里, 定义见&lt;linux/skbuff.h&gt;。这个结构从 Unix 抽象中得名, 用来代表一个网络连接socket.。对于接口来说, 一个 socket 缓存只是一个报文。</p><p>传给 hard_start_xmit 的socket 缓存包含物理报文, 它应当出现在媒介上, 以传输层的头部结束。接口不需要修改要传送的数据.。skb-&gt;data指向要传送的报文，skb-&gt;len 是以字节计的长度。传送下来的sk_buff中的数据已经包含硬件需要的帧头（这是通过hard_header函数将传递进入的信息，组织成设备特有的硬件头），所以在发送方法里不需要再填充硬件帧头，数据可以直接提 交给硬件发送。sk_buff是被锁住的(locked)，确保其他程序不会存取它。</p><p>所有的网络设备驱动程序都必须有这个发送方法。在系统调用驱动程序的xmit时，发送的数据放在一个sk_buff 结构中。一般的驱动程序把数据传给硬件发出去。也有一些特殊的设备比如loopback把数据组成一个接收数据再回送给系统，或者dummy设备直接丢弃 数据。如果发送成功，hard_start_xmit方法里释放sk_buff，返回0(发送成功)。</p><ul><li>Bcm4329芯片wlan驱动数据传送<br>当上层传送过来报文，调用hard_start_xmit函数（该方法主用于初始化数据包的传输），该函数主要用于转换sk_buf，将其组织成pktbuf数据格式，然后调用dhd_sendpkt函数将pktbuf通过dhd bus发送到wifi芯片，最后硬件wifi芯片将报文radio发送到网络上。</li></ul><p>int</p><p>dhd_start_xmit(struct sk_buff *skb,struct net_device *net)</p><p>{<br>……</p><p>        /* Convert to packet */</p><p>        if (!(pktbuf =PKTFRMNATIVE(dhd-&gt;pub.osh, skb))) {<br>                DHD_ERROR((“%s:PKTFRMNATIVE failed\n”,</p><p>                          dhd_ifname(&amp;dhd-&gt;pub, ifidx)));</p><p>                dev_kfree_skb_any(skb);        //转换成功，释放skb，在通常处理中，会在中断中做该操作</p><p>                ret = -ENOMEM;</p><p>                goto done;</p><p>        }</p><p>#ifdef WLMEDIA_HTSF</p><p>        if (htsfdlystat_sz &amp;&amp;PKTLEN(dhd-&gt;pub.osh, pktbuf) &gt;= ETHER_ADDR_LEN) {<br>                uint8 <em>pktdata = (uint8</em>)PKTDATA(dhd-&gt;pub.osh, pktbuf);</p><p>                struct ether_header *eh =(struct ether_header *)pktdata;</p><p> </p><p>                if(!ETHER_ISMULTI(eh-&gt;ether_dhost) &amp;&amp;</p><p>                       (ntoh16(eh-&gt;ether_type) == ETHER_TYPE_IP)) {<br>                        eh-&gt;ether_type =hton16(ETHER_TYPE_BRCM_PKTDLYSTATS);</p><p>                }</p><p>        }</p><p>#endif</p><p> </p><p>        ret = dhd_sendpkt(&amp;dhd-&gt;pub, ifidx,pktbuf);     //发送pktbuf</p><p>……</p><p>}</p><p> </p><p>int</p><p>dhd_sendpkt(dhd_pub_t *dhdp, intifidx, void *pktbuf)</p><p>{<br>……</p><p>#ifdef PROP_TXSTATUS</p><p>        if (dhdp-&gt;wlfc_state &amp;&amp;((athost_wl_status_info_t*)dhdp-&gt;wlfc_state)-&gt;proptxstatus_mode</p><p>                        != WLFC_FCMODE_NONE) {<br>                dhd_os_wlfc_block(dhdp);</p><p>                ret =dhd_wlfc_enque_sendq(dhdp-&gt;wlfc_state, DHD_PKTTAG_FIFO(PKTTAG(pktbuf)),</p><p>                        pktbuf);</p><p>               dhd_wlfc_commit_packets(dhdp-&gt;wlfc_state,  (f_commitpkt_t)dhd_bus_txdata,</p><p>                        dhdp-&gt;bus);</p><p>                if(((athost_wl_status_info_t*)dhdp-&gt;wlfc_state)-&gt;toggle_host_if) {<br>                        ((athost_wl_status_info_t*)dhdp-&gt;wlfc_state)-&gt;toggle_host_if= 0;</p><p>                }</p><p>                dhd_os_wlfc_unblock(dhdp);</p><p>        }</p><p>        else</p><p>                /* non-proptxstatus way */</p><p>        ret = dhd_bus_txdata(dhdp-&gt;bus, pktbuf);         //在SDIO总线上传输</p><p>#else</p><p>        ret = dhd_bus_txdata(dhdp-&gt;bus, pktbuf);</p><p>#endif /* PROP_TXST</p><p>……</p><p>}</p><p>传输结束后，会产生一个中断，即传输结束中断，一般的网络驱动程序都会有这个中断的注册，但还有一种轮询方式，这在后面的数据的接收部分会有介绍，而sk_buf就在这个中断处理函数中被释放。</p><p>但是，实际情况还是比较复杂，当硬件偶尔出现问题不能响应驱动时，就不能完成驱动的功能。在网络接口发送数据时也会发生一些不可预知的不响应动作，比如当网络介质因阻塞造成的冲突，而使发送报文的动作不能得到响应，但硬件通常不需要做此类的检测，需要驱动用软件的方法来实现，这就是超时传输机制。</p><ul><li>传输超时<br>与真实硬件打交道的大部分驱动不得不预备处理硬件偶尔不能响应。接口可能忘记它们在做什么，或者系统可能丢失中断。</li></ul><p>许多驱动通过设置定时器来处理这个问题; 如果在定时器到期时操作还没结束, 有什么不对了，网络系统, 本质上是一个复杂的由大量定时器控制的状态机的组合体。因此, 网络代码是一个合适的位置来检测发送超时, 作为它正常操作的一部分。网络驱动不需要担心自己去检测这样的问题，相反, 它们只需要设置一个超时值, 在net_device 结构的 watchdog_timeo 成员。这个超时值, 以 jiffy 计, 应当足够长以容纳正常的发送延迟(例如网络媒介拥塞引起的冲突)。</p><p>如果当前系统时间超过设备的 trans_start 时间至少 time-out 值, 网络层最终调用驱动的 tx_timeout方法。这个方法的工作是是进行清除问题需要的工作并且保证任何已经开始的发送正确地完成。特别地, 驱动没有丢失追踪任何网络代码委托给它的 socket 缓存。</p><p>当发生传送超时, 驱动必须在接口统计量中标记这个错误, 并安排设备被复位到一个干净的能发送新报文的状态，一般驱动会调用netif_wake_queue函数重新启动传输队列。</p><h1 id="数据的接收"><a href="#数据的接收" class="headerlink" title="数据的接收"></a>数据的接收</h1><ul><li>数据接收的方式和过程<br>从网络上接收报文比发送它要难一些，因为必须分配一个 sk_buff 并从一个原子性上下文中递交给上层。网络驱动可以实现 2 种报文接收的模式：中断驱动和查询，大部分驱动采用中断驱动技术。</li></ul><p>大部分硬件接口通过一个中断处理来控制，硬件中断处理器来发出 2 种可能的信号：一个新报文到了或者一个外出报文的发送完成了。网络接口也能够产生中断来指示错误, 例如状态改变, 等等。</p><p>通常的中断过程能够告知新报文到达中断和发送完成通知的区别，通过检查物理设备中的状态寄存器，来判断是那一种中断，对于发送完成中断更新状态信息，释放skb内存。而对于接收数据中断，从数据队列中抽取一包数据，并把它传递给接收函数。</p><p>注意：这里的对设备数据的操作是在锁得保护下完成的，做一最后还要释放掉锁。</p><ul><li>选择哪种接收模式<br>那么，既然后两种方式来处理网络接口发来的数据，选择那一种呢？一般认为中断是比较好的一种方式，不过，如果接口接收数据太频繁，甚至一秒中接收上千包数据，那么系统的中断次数就非常多，这回严重影响系统的性能。所以，在频繁接收数据的情况下，也可以考虑使用轮询的方式。</li></ul><p>这样，为了提高linux在宽带系统上的性能，网络子系统开发者创建了一种基于轮询方式的接口NAPI，它虽然在很多情况下，并不被看好，但处理高流量的高速接口时，用这种NAPI轮询技术处理到达的每一个数据包就足够了，前提是网络设备必须能支持这种模式，就是说一个网络接口必须能保存多个数据包，而且中断能够禁止中断并能在传输和其他事件上打开中断。</p><ul><li>Bcm4329芯片wlan驱动数据传送<br>在bcm4329芯片Wlan驱动中，在函数dhd_attach被调用时，会初始化一个内核线程或一个tasklet中断的下半部。其实这两种方式就是之前的中断和轮询方式的实现版，如果使用轮询，驱动初始化一个内核线程dhd_dpc_thread轮询网络接口接收的数据，中断下半部是中断处理程序的延续，用于处理比较复杂费时的操作，这样就能早点从中断中解放出来，防止拖累系统的性能。</li></ul><p>下面来看看这两种方式的初始化（在dhd_attach.c）：</p><p>/* Set up the bottom halfhandler */</p><p>        if (dhd_dpc_prio &gt;= 0) {<br>                /* Initialize DPC thread */</p><p>                PROC_START(dhd_dpc_thread, dhd,&amp;dhd-&gt;thr_dpc_ctl, 0);</p><p>        } else {<br>                /*  use tasklet for dpc */</p><p>                tasklet_init(&amp;dhd-&gt;tasklet, dhd_dpc,(ulong)dhd);</p><p>                dhd-&gt;thr_dpc_ctl.thr_pid =-1;</p><p>        }</p><p>首先来看看轮询方式的过程：</p><p>dhd_dpc_thread(void *data)</p><p>{<br>        tsk_ctl_t *tsk = (tsk_ctl_t *)data;</p><p>        dhd_info_t <em>dhd = (dhd_info_t</em>)tsk-&gt;parent;</p><p> </p><p>        /* This thread doesn’t need anyuser-level access,</p><p>         * so get rid of all our resources</p><p>         */</p><p>        if (dhd_dpc_prio &gt; 0)</p><p>        {<br>                struct sched_param param;</p><p>                param.sched_priority =(dhd_dpc_prio &lt; MAX_RT_PRIO)?dhd_dpc_prio:(MAX_RT_PRIO-1);</p><p>                setScheduler(current, SCHED_FIFO,&amp;param);</p><p>        }</p><p> </p><p>        DAEMONIZE(“dhd_dpc”);</p><p>        /* DHD_OS_WAKE_LOCK is called indhd_sched_dpc[dhd_linux.c] down below  */</p><p> </p><p>        /* signal: thread has started */</p><p>        complete(&amp;tsk-&gt;completed);</p><p> </p><p>        /* Run until signal received */</p><p>        while (1) {<br>                if (down_interruptible(&amp;tsk-&gt;sema)== 0) { </p><p>                       SMP_RD_BARRIER_DEPENDS();</p><p>                        if (tsk-&gt;terminated){<br>                                break;</p><p>                        }</p><p> </p><p>                        /* Call bus dpc unlessit indicated down (then clean stop) */</p><p>                        if (dhd-&gt;pub.busstate!= DHD_BUS_DOWN) {<br>                                if (dhd_bus_dpc(dhd-&gt;pub.bus)) {</p><p>                                        up(&amp;tsk-&gt;sema);</p><p>                                }</p><p>                                else {<br>                                       DHD_OS_WAKE_UNLOCK(&amp;dhd-&gt;pub);</p><p>                                }</p><p>                        } else {<br>                                if (dhd-&gt;pub.up)</p><p>                                       dhd_bus_stop(dhd-&gt;pub.bus, TRUE);</p><p>                               DHD_OS_WAKE_UNLOCK(&amp;dhd-&gt;pub);</p><p>                        }</p><p>                }</p><p>                else</p><p>                        break;</p><p>        }</p><p> </p><p>       complete_and_exit(&amp;tsk-&gt;completed, 0);</p><p>}</p><p>这里是一个永真循环，直到接收到终止信号才停止，该线程就是通过不断调用dhd_bus_dpc函数调用实现轮询的，它的调用逻辑如下所示：</p><p>上面是dhd_dpc_thread的调用逻辑，最后通过netif_rx将数据提交到上层协议，那么，还有一种中断方式时如何实现的呢？上面只看到驱动初始化了一个tasklet，一个中断下半部的实例。其实在dhdsdh_probe函数中已经注册了这个中断处理函数：</p><p>static void *</p><p>dhdsdio_probe(uint16 venid, uint16devid, uint16 bus_no, uint16 slot,</p><p>        uint16 func, uint bustype, void*regsva, osl_t * osh, void *sdh)</p><p>{<br>……</p><p>if (bus-&gt;intr) {<br>                /* Register interrupt callback,but mask it (not operational yet). */</p><p>                DHD_INTR((“%s: disableSDIO interrupts (not interested yet)\n”, <strong>FUNCTION</strong>));</p><p>                bcmsdh_intr_disable(sdh);      //首先禁止SDIO中断，再注册中断</p><p>                if ((ret= bcmsdh_intr_reg(sdh, dhdsdio_isr, bus)) != 0) {</p><p>                        DHD_ERROR((“%s:FAILED: bcmsdh_intr_reg returned %d\n”,</p><p>                                  <strong>FUNCTION</strong>, ret));</p><p>                        goto fail;</p><p>                }</p><p>                DHD_INTR((“%s: registeredSDIO interrupt function ok\n”, <strong>FUNCTION</strong>));</p><p>        } else {<br>                DHD_INFO((“%s: SDIOinterrupt function is NOT registered due to polling mode\n”,</p><p>                           <strong>FUNCTION</strong>));</p><p>        }</p><p>……</p><p>}</p><p>看看Dhdsdio_isr这个中断处理函数干了什么？在函数的最后部分是：</p><p>#if defined(SDIO_ISR_THREAD)</p><p>        DHD_TRACE((“Calling dhdsdio_dpc()from %s\n”, <strong>FUNCTION</strong>));</p><p>        DHD_OS_WAKE_LOCK(bus-&gt;dhd);</p><p>        while (dhdsdio_dpc(bus));</p><p>        DHD_OS_WAKE_UNLOCK(bus-&gt;dhd);</p><p>#else</p><p>        bus-&gt;dpc_sched = TRUE;</p><p>        dhd_sched_dpc(bus-&gt;dhd);</p><p>#endif</p><p>Dhd_sched_dpc函数在最后被调用（上面的while循环调用dhdsdio_dpc，其实和下面的这个调用函数最后的作用是一样的，就不予详述），这个函数的代码如下：</p><p>void</p><p>dhd_sched_dpc(dhd_pub_t *dhdp)</p><p>{<br>        dhd_info_t <em>dhd = (dhd_info_t</em>)dhdp-&gt;info;</p><p> </p><p>        DHD_OS_WAKE_LOCK(dhdp);</p><p>#ifdef DHDTHREAD</p><p>        if (dhd-&gt;thr_dpc_ctl.thr_pid &gt;=0) {<br>               up(&amp;dhd-&gt;thr_dpc_ctl.sema);</p><p>                return;</p><p>        }</p><p>#endif /* DHDTHREAD */</p><p> </p><p>        tasklet_schedule(&amp;dhd-&gt;tasklet);</p><p>}</p><p>就是触发一个中断的下半部tasklet，让cpu选择在一个合适的时候调用dhd_dpc函数，这个函数会调用dhd_bus_dpc，然后进入上面流程图的调用逻辑。</p><p>详细的数据处理过程不详细叙述，可以参考源码来具体分析。</p><p> </p><h1 id="电源管理相关的调用逻辑"><a href="#电源管理相关的调用逻辑" class="headerlink" title="电源管理相关的调用逻辑"></a>电源管理相关的调用逻辑</h1><p>电源管理始终是手机等移动设备最重要的一个功能，尤其对于Android这种智能手机或者说手机电脑化的设备，电源管理更显得十分重要。</p><p>Linux一直在传统的PC和服务器市场上有很好的应用，也有了比较好的电源管理框架，但是对于智能手机等嵌入式设备来说，Linux标准的电源管理就显得不是很适用了，有许多需要改进的地方。Android在这方面做了一些比较好的尝试，添加了一些新的特性，包括wake_lock，early_supend等。这里对wake_lock不做介绍，只介绍WIFI模块在系统将要或正在进入休眠的一些动作，感兴趣的话可以自己查阅android的电源管理相关文章。</p><p>在介绍实质内容之前，先来看看android的电源管理的实现基础：Linux系统的电源管理Suspend框架跟Linux系统的驱动模型（Linux DriverModel）是相关的，也是基于Linux的驱动模型来实现的，下面的图描述了Linux系统电源管理的Suspend系统框架，Linux的Suspend系统分为两部分，一部分是平台无关的核心层，另一个是平台相关的平台层。操作接口都在平台无关的核心层里了，平台相关部分会使用Suspend API将自己的操作函数注册进Suspend核心层里。</p><p>根据Linux系统驱动模型，Device结构描述了一个设备，device_driver是设备的驱动，而class、type和bus分别描述了设备所属的类别、类型和总线。而设备的电源管理也根据此模型分为class级的、type级的、bus级的和驱动级的。如果一个设备的class或者bus确切的知道如何管理一个设备的电源的时候，驱动级别的suspend/resume就可以为空了。这极大的提高了电源管理的高效性和灵活性。</p><p>对于android平台上整个系统是如何一步一步进入休眠的，我这里不做详细介绍，只作出它的大致流程图：</p><p>此流程图显示了系统的休眠的全过程，对WIFI模块来说，我们主要关注early_suspend和suspend以及相应的唤醒过程。当系统屏幕超时或用户（亮屏时）按power键，系统进入休眠流程（这里不讨论可能的中途退出休眠的其它因素），即在没有进程持有wakelock情况下，首先进入early_suspend流程。</p><p>Early_suspend流程的实现基础是：android电源管理系统中定义了一个early_suspend结构链表，里面存放了所有系统中注册了的early_suspend实例，即如果一个模块要在系统进入early_suspend状态有所动作，就必须注册一个early_suspend实例。在WIFI驱动模块中，当驱动流程走到dhd_attach函数时，有相应的early_suspend注册代码：</p><p>Path: dhd/sys/dhd_linux.c</p><p>dhd_pub_t *</p><p>dhd_attach(osl_t *osh, structdhd_bus *bus, uint bus_hdrlen)</p><p>{<br>……</p><p>#ifdef CONFIG_HAS_EARLYSUSPEND</p><p>        dhd-&gt;early_suspend.level =EARLY_SUSPEND_LEVEL_BLANK_SCREEN + 20;</p><p>        dhd-&gt;early_suspend.suspend = dhd_early_suspend;</p><p>       dhd-&gt;early_suspend.resume = dhd_late_resume;</p><p>        register_early_suspend(&amp;dhd-&gt;early_suspend);</p><p>        dhd_state |= DHD_ATTACH_STATE_EARLYSUSPEND_DONE;</p><p>#endif</p><p>……</p><p>}</p><p>红色区域初始化了dhd结构的两个early_suspend函数，并将其注册到电源管理系统。early_suspend的休眠函数的代码如下：</p><p>static void dhd_early_suspend(structearly_suspend *h)</p><p>{<br>        struct dhd_info *dhd = container_of(h,struct dhd_info, early_suspend);</p><p> </p><p>        DHD_TRACE((“%s: enter\n”,<strong>FUNCTION</strong>));</p><p> </p><p>        if (dhd)</p><p>                dhd_suspend_resume_helper(dhd, 1);</p><p>}</p><p>调用dhd_suspend_resume_helper函数，别看函数名中有resume单词，其实early_suspend和late_resume都是通过这个函数实现功能的：</p><p>static void dhd_suspend_resume_helper(structdhd_info *dhd, int val)</p><p>{<br>        dhd_pub_t *dhdp = &amp;dhd-&gt;pub;</p><p> </p><p>        DHD_OS_WAKE_LOCK(dhdp);</p><p>        /* Set flag when early suspend wascalled */</p><p>        dhdp-&gt;in_suspend = val;</p><p>        if ((!dhdp-&gt;suspend_disable_flag)&amp;&amp; (dhd_check_ap_wfd_mode_set(dhdp) == FALSE))</p><p>                dhd_set_suspend(val, dhdp);</p><p>        DHD_OS_WAKE_UNLOCK(dhdp);</p><p>}</p><p> </p><p>#if defined(CONFIG_HAS_EARLYSUSPEND)          //看这里，如果系统配置了EARLYSUSPEND       ，则系统会使用这部分代码，其实early_suspend是android对linux内核的电源管理的优化，所以如果你使用的是android平台，一定要配置该选项</p><p>static int dhd_set_suspend(intvalue, dhd_pub_t *dhd)</p><p>{<br>……</p><p>        if (dhd &amp;&amp; dhd-&gt;up) {<br>                if(value &amp;&amp; dhd-&gt;in_suspend) {        //early_suspend</p><p> </p><p>                                /* Kernelsuspended */</p><p>                               DHD_ERROR((“%s: force extra Suspend setting \n”,<strong>FUNCTION</strong>));</p><p> </p><p>                                dhd_wl_ioctl_cmd(dhd,WLC_SET_PM, (char *)&amp;power_mode,</p><p>                                                sizeof(power_mode), TRUE, 0);</p><p> </p><p>                                /* Enablepacket filter, only allow unicast packet to send up */</p><p>                               dhd_set_packet_filter(1, dhd);</p><p> </p><p>                                /* If DTIM skipis set up as default, force it to wake</p><p>                                 * each thirdDTIM for better power savings.  Note that</p><p>                                 * one sideeffect is a chance to miss BC/MC packet.</p><p>                                 */</p><p>                                bcn_li_dtim =dhd_get_dtim_skip(dhd);</p><p>                                bcm_mkiovar(“bcn_li_dtim”,(char *)&amp;bcn_li_dtim,</p><p>                                        4,iovbuf, sizeof(iovbuf));</p><p>                                dhd_wl_ioctl_cmd(dhd,WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);</p><p> </p><p>                                /* Disable firmwareroaming during suspend */</p><p>                               bcm_mkiovar(“roam_off”, (char *)&amp;roamvar, 4,</p><p>                                        iovbuf,sizeof(iovbuf));</p><p>                               dhd_wl_ioctl_cmd(dhd, WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);</p><p>                        } else {          //late_resume</p><p> </p><p>                                /* Kernelresumed  */</p><p>                               DHD_TRACE((“%s: Remove extra suspend setting \n”,<strong>FUNCTION</strong>));</p><p> </p><p>                                power_mode =PM_FAST;</p><p>                               dhd_wl_ioctl_cmd(dhd, WLC_SET_PM, (char *)&amp;power_mode,</p><p>                                                sizeof(power_mode), TRUE, 0);</p><p> </p><p>                                /* disable pktfilter */</p><p>                                dhd_set_packet_filter(0,dhd);</p><p> </p><p>                                /* restorepre-suspend setting for dtim_skip */</p><p>                               bcm_mkiovar(“bcn_li_dtim”, (char *)&amp;dhd-&gt;dtim_skip,</p><p>                                        4, iovbuf, sizeof(iovbuf));</p><p> </p><p>                                dhd_wl_ioctl_cmd(dhd,WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);</p><p>                                roamvar =dhd_roam_disable;</p><p>                               bcm_mkiovar(“roam_off”, (char *)&amp;roamvar, 4, iovbuf,</p><p>                                       sizeof(iovbuf));</p><p>                                dhd_wl_ioctl_cmd(dhd,WLC_SET_VAR, iovbuf, sizeof(iovbuf), TRUE, 0);</p><p>                        }</p><p>        }</p><p> </p><p>  return 0;</p><p>}</p><p>#endif</p><p>    具体做什么内容，可以不用过多理会，一般只是会对该模块做些最基本的低功耗设置，其实真正的低功耗设置时在suspend中完成的。一般的模块也不需要注册early_suspend实例，但是背光灯，键盘LED和LCD屏是一定要在注册的。</p><p>       Early_suspend注册成功后，会被挂接到电源管理系统中的一个链表上，当系统进入early_suspend流程时，会逐一调用该链表中的每一个实例的early_suspend回调函数，使设备进入相应的状态。在完成early_suspend流程后，系统检测wake_lock（也是被链表管理，其实不止一个），如果没有进程持有wake_lock包括main_wake_lock，系统进入suspend流程。</p><p>       同样，suspend流程的实施也是需要系统支持的，需要实现电源管理的模块需要实现suspend和resume两个函数，并注册到系统中，对于WIFI设备的电源管理函数的注册在调用wifi_add_dev函数时被注册：</p><p>Path：wl/sys/wl_android.c</p><p>static struct platform_driverwifi_device = {<br>        .probe          = wifi_probe,</p><p>        .remove         =wifi_remove,</p><p>        .suspend        = wifi_suspend,</p><p>        .resume         = wifi_resume,</p><p>        .driver         = {<br>        .name  = “bcmdhd_wlan”,</p><p>        }</p><p>};</p><p> </p><p>static struct platform_driverwifi_device_legacy = {<br>        .probe          = wifi_probe,</p><p>        .remove         = wifi_remove,</p><p>        .suspend        =wifi_suspend,</p><p>        .resume         = wifi_resume,</p><p>        .driver         = {<br>        .name  = “bcm4329_wlan”,</p><p>        }</p><p>};</p><p> </p><p>static int wifi_add_dev(void)</p><p>{<br>        DHD_TRACE((“## Callingplatform_driver_register\n”));</p><p>        platform_driver_register(&amp;wifi_device);</p><p>       platform_driver_register(&amp;wifi_device_legacy);</p><p>        return 0;</p><p>}</p><p>    Wifi_suspend和wifi_resume随着wifi_device设备的注册而注册，这样当系统进入suspend流程后，就可以调用每个设备上的电源管理函数来使设备进入休眠状态了。</p><p>       Wifi设备的休眠：</p><p>static int wifi_suspend(structplatform_device *pdev, pm_message_t state)</p><p>{<br>        DHD_TRACE((“##&gt; %s\n”,<strong>FUNCTION</strong>));</p><p>#if (LINUX_VERSION_CODE &lt;=KERNEL_VERSION(2, 6, 39)) &amp;&amp; defined(OOB_INTR_ONLY)</p><p>        bcmsdh_oob_intr_set(0);</p><p>#endif</p><p>        return 0;</p><p>}</p><p> </p><p>static int wifi_resume(structplatform_device *pdev)</p><p>{<br>        DHD_TRACE((“##&gt; %s\n”,<strong>FUNCTION</strong>));</p><p>#if (LINUX_VERSION_CODE &lt;=KERNEL_VERSION(2, 6, 39)) &amp;&amp; defined(OOB_INTR_ONLY)</p><p>        if (dhd_os_check_if_up(bcmsdh_get_drvdata()))</p><p>                bcmsdh_oob_intr_set(1);</p><p>#endif</p><p>        return 0;</p><p>}</p><p>       上面的两个电源管理函数都调用bcmsdh_oob_intr_set函数，但是传递的参数不同，在wifi_suspend函数中传递0，表示禁止wifi设备对应的oob中断，而wifi_resume的作用恰恰相反。</p><p>       Bcmsdh_oob_intr_set函数的定义如下：</p><p>PATH：bcmsdio/sys/bcmsdh_linux.c</p><p>#if defined(OOB_INTR_ONLY)   //该中断的使用需要配置</p><p>void bcmsdh_oob_intr_set(bool enable)</p><p>{<br>        static bool curstate = 1;</p><p>        unsigned long flags;</p><p> </p><p>       spin_lock_irqsave(&amp;sdhcinfo-&gt;irq_lock, flags);</p><p>        if (curstate != enable) {</p><p>                if (enable)</p><p>                       enable_irq(sdhcinfo-&gt;oob_irq);</p><p>                else</p><p>                       disable_irq_nosync(sdhcinfo-&gt;oob_irq);</p><p>                curstate =enable;</p><p>        }</p><p>       spin_unlock_irqrestore(&amp;sdhcinfo-&gt;irq_lock, flags);</p><p>}</p><p>      </p><p>此中断是在打开wifi网络设备的时候被注册的，流程如下：</p><p>static int</p><p>dhd_open(struct net_device *net)</p><p>{<br>……</p><p>               if (dhd-&gt;pub.busstate !=DHD_BUS_DATA) { </p><p>                        /* try to bring up bus*/</p><p>                        if ((ret = dhd_bus_start(&amp;dhd-&gt;pub)) !=0) {</p><p>                               DHD_ERROR((“%s: failed with code %d\n”, <strong>FUNCTION</strong>, ret));</p><p>                                ret = -1;</p><p>                                goto exit;</p><p>                        }</p><p> </p><p>                }</p><p>……</p><p>}</p><p> </p><p> </p><p>dhd_bus_start(dhd_pub_t *dhdp)</p><p>{<br>……</p><p>#if defined(OOB_INTR_ONLY)</p><p>        /* Host registration for OOB interrupt*/</p><p>        if(bcmsdh_register_oob_intr(dhdp)) {</p><p>……</p><p>}</p><p>在系统进入suspend状态后，wifi设备进入禁止中断状态，不再接收处理网络发来的数据，系统进入sleep状态，当然还有很多cpu在suspend之后进入sleep状态，但此时系统clock中断并没有被禁止，而且pmu还正常工作，以期对power键和充电器连接的检测。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IOCTL的调用逻辑&quot;&gt;&lt;a href=&quot;#IOCTL的调用逻辑&quot; class=&quot;headerlink&quot; title=&quot;IOCTL的调用逻辑&quot;&gt;&lt;/a&gt;IOCTL的调用逻辑&lt;/h1&gt;&lt;p&gt;之所以要分析这个，是因为上层wpa_supplicant和WIFI驱动打交道</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>信号幽灵wifi（第三篇）</title>
    <link href="http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E4%B8%89%E7%AF%87%EF%BC%89/</id>
    <published>2021-03-06T10:38:13.000Z</published>
    <updated>2021-03-06T10:41:30.830Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WLAN驱动结构介绍"><a href="#WLAN驱动结构介绍" class="headerlink" title="WLAN驱动结构介绍"></a>WLAN驱动结构介绍</h1><ul><li>SDIO驱动<br>在drivers/mmc下面是mmc卡，SD卡和SDIO卡驱动部分，其中包括host驱动，card驱动和core部分，由于网络接口卡挂接在SDIO总线上，所以在此之前我们先看一下SDIO的驱动结构。其驱动在drivers/mmc目录下的结构为：</li></ul><p> </p><p>|– mmc</p><p>|   |– card</p><p>|   |– core</p><p>|   |– host</p><p> </p><p>主要关注的目录是core目录，这个目录是真个驱动的核心目录，是媒体卡的通用代码部分，包括core.c，host.c和sdio.c等。CORE 层完成了不同协议和规范的实现，并为HOST 层的驱动提供了接口函数，该目录完成sdio总线的注册操作，相应的ops操作，以及支持mmc的代码。详细的情况将在函数接口部分详细讨论。</p><p>Host目录是不同平台根据平台的特性而编写的host驱动。</p><h2 id="Boardcom无线通讯芯片"><a href="#Boardcom无线通讯芯片" class="headerlink" title="Boardcom无线通讯芯片"></a>Boardcom无线通讯芯片</h2><ul><li>概述<br>全球有线和无线通信半导体市场的领导者Broadcom（博通）公司（Nasdaq：BRCM）宣布，推出最新无线组合芯片BCM4330，该芯片可支持更多媒体形式和数据应用，且不会增大智能手机、平板电脑及其他移动设备的尺寸或缩短其电池寿命。BCM4330在单个芯片上集成了业界领先的Broadcom 802.11n Wi-Fi、蓝牙和FM无线技术，与分立式半导体器件组成的解决方案相比，在成本、尺寸、功耗和性能上有显著优势，是移动设备的理想选择。</li></ul><p>BCM4330采用了新的Wi-Fi和蓝牙标准，可支持新的、令人振奋的应用。例如，Broadcom BCM4330是业界第一款经过蓝牙4.0标准认证的组合芯片解决方案， 集成了蓝牙低功耗（BLE）标准。该标准使蓝牙技术能以超低功耗运行，因此BCM4330非常适用于需要很长电池寿命的系统，如无线传感器、医疗和健身监控设备等。BCM4330还支持Wi-Fi Direct™和蓝牙高速（HS）标准，因此采用BCM4330的移动设备能直接相互通信，而不必先连接到接入点、成为传统网络的一部分，从而为很多无线设备之间新的应用和使用模式创造了机会。</p><p>Broadcom一直支持所有主流的操作系统（OS）平台，如MicrosoftWindows和Windows Phone、Google Chrome、Android等等，而且不仅是BCM4330，所有蓝牙、WLAN和GPS芯片组都提供这样的支持。</p><ul><li>源码<br>Bcm4330驱动源码一般被厂商单独提供，如果要在开发的LINUX系统中（当然它还支持多种平台）使用该源码，可以添加到linux kernel源码树里，也可以单独组织存放，可以直接编译到kernel，也可以编译成模块，然后再系统启动的流程中或其他适当的实际加载到kernel中，一般建议单独组织并编译成模块在需要的时候加载如kernel。</li></ul><p>|– src</p><p>|   |– bcmsdio</p><p>|   |– dhd</p><p>|   |–dongle</p><p>|   |–include</p><p>|   |– shared</p><p>|   |– wl</p><p> </p><p>这里主要内容到bcmsdio，dhd和wl三个目录下，bcm4330驱动的入口在dhd/sys/dhd_linux.c文件中的dhd_module()函数，设备的初始化和相关驱动注册都从这里开始，</p><h2 id="详细接口及代码分析"><a href="#详细接口及代码分析" class="headerlink" title="详细接口及代码分析"></a>详细接口及代码分析</h2><ul><li>WIFI驱动流程分析<br>    以boardcom bcm4329芯片驱动为例，相应的函数流程图如下：       </li></ul><p>                       </p><ul><li>WIFI设备注册流程<br>Platform_driver_register(wifi_device[_legacy])的调用将wifi_device[_legacy]驱动注册到系统中，wifi_device_legacy是为了兼容老版本的驱动。</li></ul><p>Path: wl/sys/wl_android.c</p><p>Static struct Platform_driver wifi_device ={<br>         .probe     =     wifi_probe</p><p>         .remove   =     wifi_remove</p><p>         .suspend  =     wifi_supend</p><p>         .resume   =     wifi_resume</p><p>         .driver     =     {<br>         .name      =     “bcmdhd_wlan”</p><p>}</p><p>}</p><p> </p><p>Static struct Platform_driver wifi_device_legacy ={<br>         .probe     =     wifi_probe</p><p>         .remove   =     wifi_remove</p><p>         .suspend  =     wifi_supend</p><p>         .resume   =     wifi_resume</p><p>         .driver     =     {<br>         .name      =     “bcm4329_wlan”</p><p>}</p><p>}</p><p>上面的展示了wifi平台设备驱动的注册过程，那么在平台相关的代码区应该有wifi作为平台设备被初始化和注册的地方：</p><p>Path: kernel/arch/arm/mach-msm/msm_</p><p>static struct resource mahimahi_wifi_resources[] = {</p><p>        [0] = {<br>                .name           = “bcm4329_wlan_irq”,</p><p>                .start          =MSM_GPIO_TO_INT(MAHIMAHI_GPIO_WIFI_IRQ),</p><p>                .end            = MSM_GPIO_TO_INT(MAHIMAHI_GPIO_WIFI_IRQ),</p><p>                .flags          = IORESOURCE_IRQ |IORESOURCE_IRQ_HIGHLEVEL | IORESOURCE_IRQ_SHAREABLE,</p><p>        },</p><p>};</p><p> </p><p>static structwifi_platform_data mahimahi_wifi_control = {<br>        .set_power      = mahimahi_wifi_power,</p><p>        .set_reset      = mahimahi_wifi_reset,</p><p>        .set_carddetect = mahimahi_wifi_set_carddetect,</p><p>        .mem_prealloc   = mahimahi_wifi_mem_prealloc,</p><p>};</p><p> </p><p>static struct platform_device mahimahi_wifi_device = {</p><p>        .name           = “bcm4329_wlan”,</p><p>        .id             = 1,</p><p>        .num_resources  = ARRAY_SIZE(mahimahi_wifi_resources),</p><p>        .resource       = mahimahi_wifi_resources,</p><p>        .dev            = {</p><p>               .platform_data = &amp;mahimahi_wifi_control,</p><p>        },</p><p>};</p><p>上面是对wifi_device设备的初始化，下面是对该设备的注册：</p><p>static int __initmahimahi_wifi_init(void)</p><p>{<br>        int ret;</p><p> </p><p>        if (!machine_is_mahimahi())</p><p>                return 0;</p><p> </p><p>        printk(“%s: start\n”,<strong>func</strong>);</p><p>       mahimahi_wifi_update_nvs(“sd_oobonly=1\r\n”, 0);</p><p>       mahimahi_wifi_update_nvs(“btc_params70=0x32\r\n”, 1);</p><p>        mahimahi_init_wifi_mem();</p><p>        ret = platform_device_register(&amp;mahimahi_wifi_device);</p><p>        return ret;</p><p>}</p><p> </p><p>late_initcall(mahimahi_wifi_init);      //表明在系统启动的后期会自动调用加载该模块</p><p>这样，通过上面的初始化和注册流程，wifi设备作为平台设备和驱动就可以握手成功了，这里的平台驱动只是对wifi设备的简单管理，如对wifi设备的挂起和恢复等操作了。但是在wifi设备初始化之前是不能够被挂起和恢复的，那么wifi设备是如何初始化的呢？</p><p>Path: wl/sys/wl_android.c</p><p>static int wifi_probe(structplatform_device *pdev)</p><p>{<br>        struct wifi_platform_data *wifi_ctrl =</p><p>                (structwifi_platform_data *)(pdev-&gt;dev.platform_data);</p><p> </p><p>        DHD_ERROR((“## %s\n”,<strong>FUNCTION</strong>));</p><p>        wifi_irqres = platform_get_resource_byname(pdev,IORESOURCE_IRQ, “bcmdhd_wlan_irq”);</p><p>        if (wifi_irqres == NULL)</p><p>                wifi_irqres =platform_get_resource_byname(pdev,</p><p>                        IORESOURCE_IRQ,”bcm4329_wlan_irq”);</p><p>        wifi_control_data = wifi_ctrl;</p><p> </p><p>        wifi_set_power(1,0);   /* Power On */</p><p>       wifi_set_carddetect(1); /* CardDetect (0-&gt;1) */</p><p> </p><p>        up(&amp;wifi_control_sem);</p><p>        return 0;</p><p>}</p><p>这是wifi平台设备驱动注册时成功匹配wifi设备后调用的函数wifi_probe()，它的主要工作就是从wifi设备中获取终端资源，并获取wifi_platform_data类型结构赋予wifi_control_data变量，这一步很重要，下面就可以看出了它的重要性。然后调用wifi_set_power和wifi_set_carddetect函数给wifi芯片上电并检测。</p><p>int wifi_set_power(int on, unsignedlong msec)</p><p>{<br>        DHD_ERROR((“%s = %d\n”,<strong>FUNCTION</strong>, on));</p><p>        if (wifi_control_data &amp;&amp;wifi_control_data-&gt;set_power) {<br>                wifi_control_data-&gt;set_power(on);</p><p>        }</p><p>        if (msec)</p><p>                msleep(msec);</p><p>        return 0;</p><p>}</p><p>Wifi_set_power函数中调用wifi_control_data-&gt;set_power(on)，wifi_control_data就是刚才说的那个重要变量，注意它是从wifi_device平台设备的wifi_platform_data获取的，那么看看上面的wifi_device初始化的代码：</p><p>static struct platform_device mahimahi_wifi_device = {</p><p>        .name           = “bcm4329_wlan”,</p><p>        .id             = 1,</p><p>        .num_resources  = ARRAY_SIZE(mahimahi_wifi_resources),</p><p>        .resource       = mahimahi_wifi_resources,</p><p>        .dev            = {</p><p>                .platform_data =&amp;mahimahi_wifi_control,</p><p>        },</p><p>};</p><p> </p><p>static struct wifi_platform_datamahimahi_wifi_control= {<br>        .set_power      = mahimahi_wifi_power,</p><p>        .set_reset      = mahimahi_wifi_reset,</p><p>        .set_carddetect = mahimahi_wifi_set_carddetect,</p><p>        .mem_prealloc   = mahimahi_wifi_mem_prealloc,</p><p>};</p><p>所以它实际调用的是mahimahi_wifi_power函数，该函数的定义在kernel/arch/arm /mach-msm/board-mahimahi-mmc.c之中：</p><p>int mahimahi_wifi_power(int on)</p><p>{<br>       printk(“%s: %d\n”, <strong>func</strong>, on);</p><p> </p><p>        if (on) {<br>               config_gpio_table(wifi_on_gpio_table,</p><p>                                  ARRAY_SIZE(wifi_on_gpio_table));</p><p>               mdelay(50);</p><p>        } else {<br>               config_gpio_table(wifi_off_gpio_table,</p><p>                                 ARRAY_SIZE(wifi_off_gpio_table));</p><p>        }</p><p> </p><p>        mdelay(100);</p><p>        gpio_set_value(MAHIMAHI_GPIO_WIFI_SHUTDOWN_N,on); /* WIFI_SHUTDOWN */</p><p>        mdelay(200);</p><p> </p><p>       mahimahi_wifi_power_state = on;</p><p>        return 0;</p><p>}</p><p>调用gpio_set_value操作wifi芯片，给wifi芯片上电。那么来看看wifi_set_ carddetect函数究竟干了什么：</p><p>Path：wl/sys/wl_android.c</p><p>static int wifi_set_carddetect(int on)</p><p>{<br>       DHD_ERROR((“%s = %d\n”, <strong>FUNCTION</strong>, on));</p><p>        if(wifi_control_data &amp;&amp; wifi_control_data-&gt;set_carddetect) {<br>               wifi_control_data-&gt;set_carddetect(on);</p><p>        }</p><p>        return 0;</p><p>}</p><p>同样会调用wifi_device的mahimahi_wifi_set_carddetect函数：</p><p>Path:kernel/arch/arm/mach-msm/board-mahimahi-mmc.c</p><p>int mahimahi_wifi_set_carddetect(int val)</p><p>{<br>       pr_info(“%s: %d\n”, <strong>func</strong>, val);</p><p>       mahimahi_wifi_cd = val;</p><p>        if(wifi_status_cb) {<br>                wifi_status_cb(val,wifi_status_cb_devid);</p><p>        } else</p><p>               pr_warning(“%s: Nobody to notify\n”, <strong>func</strong>);</p><p>        return 0;</p><p>}</p><p>Wifi_status_cb代码：</p><p>static int mahimahi_wifi_status_register(</p><p>                        void (*callback)(intcard_present, void *dev_id),</p><p>                        void *dev_id)</p><p>{<br>        if (wifi_status_cb)</p><p>                return -EAGAIN;</p><p>        wifi_status_cb = callback;</p><p>        wifi_status_cb_devid = dev_id;</p><p>        return 0;</p><p>}</p><p> </p><p>static unsigned intmahimahi_wifi_status(struct device *dev)</p><p>{<br>        return mahimahi_wifi_cd;</p><p>}</p><p> </p><p>static structmmc_platform_data mahimahi_wifi_data = {<br>        .ocr_mask               = MMC_VDD_28_29,</p><p>        .built_in               = 1,</p><p>        .status                 = mahimahi_wifi_status,</p><p>        .register_status_notify= mahimahi_wifi_status_register,</p><p>        .embedded_sdio          = &amp;mahimahi_wifi_emb_data,</p><p>};</p><p>由上面代码；不难看出会有个地方调用mahimahi_wifi_status_register设置wifi_status_cb这个回调函数，可以跟踪这个mahimahi_wifi_data结构体，来看看它被传递给了谁：</p><p>int msm_add_sdcc(unsigned intcontroller, struct mmc_platform_data *plat,</p><p>                 unsigned int stat_irq,unsigned long stat_irq_flags);</p><p> </p><p>int __initmahimahi_init_mmc(unsigned int sys_rev, unsigned debug_uart)</p><p>{<br>        ……</p><p> </p><p>        msm_add_sdcc(1, &amp;mahimahi_wifi_data, 0, 0);</p><p> </p><p>       ……</p><p>        if (system_rev &gt; 0)</p><p>                msm_add_sdcc(2,&amp;mahimahi_sdslot_data, 0, 0);</p><p>        else {<br>                mahimahi_sdslot_data.status =mahimahi_sdslot_status_rev0;</p><p>               mahimahi_sdslot_data.register_status_notify = NULL;</p><p>               set_irq_wake(MSM_GPIO_TO_INT(MAHIMAHI_GPIO_SDMC_CD_REV0_N), 1);</p><p>                msm_add_sdcc(2, &amp;mahimahi_sdslot_data,</p><p>         ……</p><p>}</p><p>可以跟踪到这里Path：kernel/arch/arm/mach-msm/devices-msm7x30.c</p><p>struct platform_device msm_device_sdc1 = {</p><p>        .name           = “msm_sdcc”,</p><p>        .id             = 1,</p><p>        .num_resources  = ARRAY_SIZE(resources_sdc1),</p><p>        .resource       = resources_sdc1,</p><p>        .dev            = {</p><p>               .coherent_dma_mask      =0xffffffff,</p><p>        },</p><p>};</p><p> </p><p>struct platform_device msm_device_sdc2 = {</p><p>        .name           = “msm_sdcc”,</p><p>        .id             = 2,</p><p>        .num_resources  = ARRAY_SIZE(resources_sdc2),</p><p>        .resource       = resources_sdc2,</p><p>        .dev            = {</p><p>               .coherent_dma_mask      =0xffffffff,</p><p>        },</p><p>};</p><p> </p><p>struct platform_devicemsm_device_sdc3 = {<br>        .name           = “msm_sdcc”,</p><p>        .id             = 3,</p><p>        .num_resources  = ARRAY_SIZE(resources_sdc3),</p><p>        .resource       = resources_sdc3,</p><p>        .dev            = {<br>                .coherent_dma_mask      = 0xffffffff,</p><p>        },</p><p>};</p><p> </p><p>struct platform_device msm_device_sdc4= {<br>        .name           = “msm_sdcc”,</p><p>        .id             = 4,</p><p>        .num_resources  = ARRAY_SIZE(resources_sdc4),</p><p>        .resource       = resources_sdc4,</p><p>        .dev            = {<br>                                                                                                                         439,2-16      62%</p><p>                .coherent_dma_mask      = 0xffffffff,</p><p>        },</p><p>};</p><p> </p><p>static struct platform_device *msm_sdcc_devices[] __initdata = {</p><p>        &amp;msm_device_sdc1,</p><p>        &amp;msm_device_sdc2,</p><p>        &amp;msm_device_sdc3,</p><p>        &amp;msm_device_sdc4,</p><p>};</p><p> </p><p>int __initmsm_add_sdcc(unsigned int controller, struct mmc_platform_data *plat,</p><p>                        unsigned int stat_irq,unsigned long stat_irq_flags)</p><p>{<br>        ……</p><p> </p><p>        pdev =msm_sdcc_devices[controller-1]; //因为传过来的controller是1，所以下面注册的是第一个平台设备</p><p>        pdev-&gt;dev.platform_data= plat;  //被传递给平台设备的platform_data</p><p> </p><p>        res =platform_get_resource_byname(pdev, IORESOURCE_IRQ, “status_irq”);</p><p>        if (!res)</p><p>                return -EINVAL;</p><p>        else if (stat_irq) {<br>                res-&gt;start = res-&gt;end =stat_irq;</p><p>                res-&gt;flags &amp;=~IORESOURCE_DISABLED;</p><p>                res-&gt;flags |=stat_irq_flags;</p><p>        }</p><p> </p><p>        return platform_device_register(pdev); //如上所述</p><p>}</p><p>那么这个平台设备是什么呢，就是sd卡控制器，也就是前面说的host驱动所驱动的主机控制设备。</p><p>Path: drivers/mmc/host/msm_sdcc.c</p><p>static struct platform_drivermsmsdcc_driver = {<br>        .probe          = msmsdcc_probe,</p><p>        .suspend        = msmsdcc_suspend,</p><p>        .resume         = msmsdcc_resume,</p><p>        .driver         = {<br>                .name   = “msm_sdcc”,</p><p>        },</p><p>};</p><p> </p><p>static int __initmsmsdcc_init(void)</p><p>{<br>        return platform_driver_register(&amp;msmsdcc_driver);</p><p>}</p><p>驱动成功匹配设备后，调用probe函数：</p><p>static int</p><p>msmsdcc_probe(structplatform_device *pdev)</p><p>{<br>……</p><p>if (stat_irqres &amp;&amp;!(stat_irqres-&gt;flags &amp; IORESOURCE_DISABLED)) {<br>……</p><p>        } else if(plat-&gt;register_status_notify) {<br>                plat-&gt;register_status_notify(msmsdcc_status_notify_cb,host);</p><p>        } else if (!plat-&gt;status)</p><p>……</p><p>}</p><p>msmsdcc_status_notify_cb调用msmsdcc_check_status函数：</p><p>msmsdcc_status_notify_cb(intcard_present, void *dev_id)</p><p>{<br>        struct msmsdcc_host *host = dev_id;</p><p> </p><p>        printk(KERN_DEBUG “%s:card_present %d\n”, mmc_hostname(host-&gt;mmc),</p><p>               card_present);</p><p>        msmsdcc_check_status((unsigned long) host);</p><p>}</p><p>msmsdcc_check_status调用mmc_detect_change函数：</p><p>static void</p><p>msmsdcc_check_status(unsignedlong data)</p><p>{<br>        ……</p><p>        if (status ^ host-&gt;oldstat) {<br>                pr_info(“%s: Slot statuschange detected (%d -&gt; %d)\n”,</p><p>                        mmc_hostname(host-&gt;mmc),host-&gt;oldstat, status);</p><p>                if (status &amp;&amp;!host-&gt;plat-&gt;built_in)</p><p>                        mmc_detect_change(host-&gt;mmc, (5 * HZ) / 2);</p><p>                else</p><p>                        mmc_detect_change(host-&gt;mmc, 0);</p><p>        }</p><p> </p><p>        host-&gt;oldstat = status;</p><p> </p><p>out:</p><p>        if (host-&gt;timer.function)</p><p>                mod_timer(&amp;host-&gt;timer,jiffies + HZ);</p><p>}</p><p>可以看到mmc_detect_change被调用了，这个函数触发了一个延时工作：</p><p>void mmc_detect_change(structmmc_host *host, unsigned long delay)</p><p>{<br>……</p><p> </p><p>        mmc_schedule_delayed_work(&amp;host-&gt;detect, delay);</p><p>}</p><p>这个时候它会在delay时间后，执行host-&gt;detect延时工作对应的函数，在host驱动注册并匹配设备成功后执行的probe函数里，会调用mmc_alloc_host动态创建一个mmc_host：</p><p>msmsdcc_probe(structplatform_device *pdev)</p><p>{<br>……</p><p>/*</p><p>         * Setup our host structure</p><p>         */</p><p> </p><p>        mmc = mmc_alloc_host(sizeof(struct msmsdcc_host),&amp;pdev-&gt;dev);</p><p>        if (!mmc) {<br>                ret = -ENOMEM;</p><p>                goto out;</p><p>        }</p><p>……</p><p>}</p><p>mmc_alloc_host初始化工作入口：</p><p>struct mmc_host*mmc_alloc_host(int extra, struct device *dev)</p><p>{<br>……</p><p>INIT_DELAYED_WORK(&amp;host-&gt;detect, mmc_rescan);</p><p>……</p><p>}</p><p>mmc_rescan是core.c中一个很重要的函数，它遵照 SDIO 卡协议的 SDIO 卡启动过程，包括了非激活模式、卡识别模式和数据传输模式三种模式共九种状态的转换，你需要参照相关规范来理解。</p><p>void mmc_rescan(structwork_struct *work)</p><p>{<br>        struct mmc_host *host =</p><p>                container_of(work, structmmc_host, detect.work);</p><p>……</p><p>        mmc_power_up(host);</p><p>        sdio_reset(host);</p><p>        mmc_go_idle(host);</p><p> </p><p>       mmc_send_if_cond(host, host-&gt;ocr_avail);</p><p> </p><p>        /*</p><p>         * First we search for SDIO…</p><p>         */</p><p>        err = mmc_send_io_op_cond(host, 0, &amp;ocr);</p><p>        if (!err) {<br>                if (mmc_attach_sdio(host, ocr))</p><p>                        mmc_power_off(host);</p><p>                extend_wakelock = 1;</p><p>                goto out;</p><p>        }</p><p>……</p><p>}</p><p>这个mmc_attach_sdio函数很重要，它是SDIO卡的初始化的起点，主要工作包括：匹配SDIO卡的工作电压，分配并初始化mmc_card结构，然后注册mmc_card到系统中：</p><p>/*</p><p> * Starting point for SDIO card init.</p><p> */</p><p>int mmc_attach_sdio(structmmc_host *host, u32 ocr)</p><p>{<br>        ……</p><p> </p><p>        mmc_attach_bus(host,&amp;mmc_sdio_ops);  //初始化host的bus_ops</p><p> </p><p>       ……</p><p> </p><p>        host-&gt;ocr = mmc_select_voltage(host, ocr); //匹配SDIO卡工作电压</p><p> </p><p>        ……</p><p> </p><p>        /*</p><p>         * Detect and init the card.</p><p>         */</p><p>        err = mmc_sdio_init_card(host, host-&gt;ocr, NULL, 0);//检测，分配初始化mmc_card</p><p>        if (err)</p><p>                goto err;</p><p>        card = host-&gt;card;</p><p>/*</p><p>         * If needed, disconnect card detectionpull-up resistor.</p><p>         */</p><p>        err = sdio_disable_cd(card);</p><p>        if (err)</p><p>                goto remove;</p><p> </p><p>        /*</p><p>         * Initialize (but don’t add) all present functions.</p><p>         */</p><p>        for (i = 0; i &lt; funcs; i++, card-&gt;sdio_funcs++) {</p><p>#ifdef CONFIG_MMC_EMBEDDED_SDIO</p><p>                if(host-&gt;embedded_sdio_data.funcs) {</p><p>                       struct sdio_func *tmp;</p><p> </p><p>                        tmp = sdio_alloc_func(host-&gt;card);</p><p>                        if(IS_ERR(tmp))</p><p>                               goto remove;</p><p>                       tmp-&gt;num = (i + 1);</p><p>                       card-&gt;sdio_func[i] = tmp;</p><p>                       tmp-&gt;class = host-&gt;embedded_sdio_data.funcs[i].f_class;</p><p>                       tmp-&gt;max_blksize = host-&gt;embedded_sdio_data.funcs[i].f_maxblksize;</p><p>                       tmp-&gt;vendor = card-&gt;cis.vendor;</p><p>                       tmp-&gt;device = card-&gt;cis.device;</p><p>                } else {</p><p>#endif</p><p>                        err =sdio_init_func(host-&gt;card, i + 1);</p><p>                        if (err)</p><p>                                goto remove;</p><p>#ifdefCONFIG_MMC_EMBEDDED_SDIO</p><p>                }</p><p>#endif</p><p>        }</p><p> </p><p>        mmc_release_host(host);</p><p> </p><p>        /*</p><p>         * First add the card to the drivermodel…</p><p>         */</p><p>        err = mmc_add_card(host-&gt;card);     //添加mmc_card</p><p>        if (err)</p><p>                goto remove_added;</p><p> </p><p>        /*</p><p>         * …then the SDIO functions.</p><p>         */</p><p>        for (i = 0;i &lt; funcs;i++) {<br>                err =sdio_add_func(host-&gt;card-&gt;sdio_func[i]);              //将sdio_func加入系统</p><p>                if (err)</p><p>                       goto remove_added;</p><p>        }</p><p> </p><p>        return 0;</p><p>……</p><p>}</p><p>这样，SDIO卡已经初始化成功并添加到了驱动中。上面说的过程是在SDIO设备注册时的调用流程，mmc_rescan是整个流程主体部分，由它来完成SDIO设备的初始化和添加。其实上面的流程只是创建，初始化，添加SDIO设备的一条线，还有另外的两条线也会调用mmc_rescan函数进行SDIO设备的上述操作：</p><ul><li><p>加载SDIO host驱动模块</p></li><li><p>SDIO设备中断</p></li><li><p>加载SDIO host驱动模块<br>Host作为平台设备被注册，前面也有列出相应源码：</p></li></ul><p>static struct platform_drivermsmsdcc_driver = {<br>        .probe          = msmsdcc_probe,</p><p>        .suspend        = msmsdcc_suspend,</p><p>        .resume         = msmsdcc_resume,</p><p>        .driver         = {<br>                .name   = “msm_sdcc”,</p><p>        },</p><p>};</p><p> </p><p>static int __initmsmsdcc_init(void)</p><p>{<br>        returnplatform_driver_register(&amp;msmsdcc_driver);</p><p>}</p><p> </p><p>Probe函数会调用mmc_alloc_host函数（代码前面已经贴出）来创建mmc_host结构变量，进行必要的初始化之后，调用mmc_add_host函数将它添加到驱动里面：</p><p>int mmc_add_host(structmmc_host *host)</p><p>{<br>        ……</p><p> </p><p>        err =device_add(&amp;host-&gt;class_dev);</p><p>        if (err)</p><p>                return err;</p><p>        mmc_start_host(host);</p><p>        if (!(host-&gt;pm_flags &amp;MMC_PM_IGNORE_PM_NOTIFY))</p><p>                register_pm_notifier(&amp;host-&gt;pm_notify);</p><p> </p><p>        return 0;</p><p>}</p><p>       Mmc_start_host定义如下：</p><p>void mmc_start_host(structmmc_host *host)</p><p>{</p><p>      mmc_power_off(host);</p><p>       mmc_detect_change(host, 0);</p><p>}</p><p>mmc_power_off中对 ios进行了设置，然后调用 mmc_set_ios(host);</p><p>host-&gt;ios.power_mode = MMC_POWER_OFF;</p><p>       host-&gt;ios.bus_width = MMC_BUS_WIDTH_1;</p><p>       host-&gt;ios.timing =MMC_TIMING_LEGACY;</p><p>       mmc_set_ios(host);</p><p>mmc_set_ios(host) 中的关键语句 host-&gt;ops-&gt;set_ios(host, ios)，实际上在host驱动的probe函数中就已经对host-&gt;ops进行了初始化：</p><p>……</p><p>/*</p><p>         * Setup MMC host structure</p><p>         */</p><p>        mmc-&gt;ops = &amp;msmsdcc_ops;</p><p>……</p><p> </p><p>static const structmmc_host_ops msmsdcc_ops = {<br>        .request        = msmsdcc_request,</p><p>        .set_ios        =msmsdcc_set_ios,</p><p>        .enable_sdio_irq =msmsdcc_enable_sdio_irq,</p><p>};</p><p> </p><p>所以实际上调用的是msmsdcc_set_ios，关于这个函数就不介绍了，可以参考源码，再看 mmc_detect_change(host, 0)，最后一句是：</p><p>      mmc_schedule_delayed_work(&amp;host-&gt;detect,delay);</p><p>实际上就是调用我们前面说的延时函数 mmc_rescan，后面的流程是一样的。</p><ul><li>SDIO设备中断<br>SDIO设备通过SDIO总线与host相连，SDIO总线的DAT[1]即pin8可以作为中断线使用，当SDIO设备向host产生中断时，host会对终端做出相应的动作，在host驱动的probe函数中申请并注册相应的中断函数：</li></ul><p>static int</p><p>msmsdcc_probe(structplatform_device *pdev)</p><p>{<br>……</p><p>  cmd_irqres = platform_get_resource_byname(pdev, IORESOURCE_IRQ,</p><p>                                                 “cmd_irq”);</p><p>        pio_irqres =platform_get_resource_byname(pdev, IORESOURCE_IRQ,</p><p>                                                 “pio_irq”);</p><p>        stat_irqres =platform_get_resource_byname(pdev, IORESOURCE_IRQ,</p><p>                                                  “status_irq”);</p><p>……</p><p>  if (stat_irqres &amp;&amp; !(stat_irqres-&gt;flags &amp;IORESOURCE_DISABLED)) {<br>                unsigned long irqflags =IRQF_SHARED |</p><p>                        (stat_irqres-&gt;flags&amp; IRQF_TRIGGER_MASK);</p><p> </p><p>                host-&gt;stat_irq = stat_irqres-&gt;start;</p><p>                ret = request_irq(host-&gt;stat_irq,</p><p>                                  msmsdcc_platform_status_irq,</p><p>                                 irqflags,</p><p>                                 DRIVER_NAME “ (slot)”,</p><p>                                 host);</p><p>                if (ret) {<br>                        pr_err(“%s: Unableto get slot IRQ %d (%d)\n”,</p><p>                              mmc_hostname(mmc), host-&gt;stat_irq, ret);</p><p>                        goto clk_disable;</p><p>                }</p><p>        }</p><p>……</p><p>}</p><p>当产生相应的中断时调用msmsdcc_platform_status_irq中断处理函数，这个函数的处理流程：</p><p>msmsdcc_platform_status_irq—&gt;</p><p>msmsdcc_check_statusà</p><p>mmc_detect_changeà</p><p>mmc_rescanà</p><p>那么，这里为何调用mmc_rescan呢？因为前面说过mmc_rescanrescan函数主要用于SDIO设备的初始化，如果SDIO设备产生中断不应该是已经初始化可以使用了吗？其实mmc_rescan还有其它的工作，从函数名就能看出来它还有再扫描检测功能，即如果设备产生了中断，mmc_rescan函数一开始就会再次检测所有挂接在该host上的所有SDIO设备，确认是否存在，如果不存在就做相应的释放工作，以确保数据的一致性。如果检测到了新的设备那么它就会创建一个新的mmc_card，初始化并添加该设备。</p><p>中断引发的调用mmc_rescan动作的意义：实现了SDIO设备的热插拔功能。</p><h2 id="WIFI驱动流程（二）"><a href="#WIFI驱动流程（二）" class="headerlink" title="WIFI驱动流程（二）"></a>WIFI驱动流程（二）</h2><p>  此调用流程由dhd_bus_register发起，通过sdio_register_driver注册一个sdio设备驱动，然后通过dhdsdio_probe初始化并注册一个网络设备，网络设备的注册标志着wifi驱动已经成功加载，关于网络设备的创建，初始化和注册后面会有详细介绍，先来理一下上面的调用流程，：</p><p> </p><p>dhd_mudule_init—&gt;             //path:dhd/sys/dhd_linux.c</p><p>Dhd_bus_registerà        // dhd/sys/dhd_sdio.c</p><p>Bcmsdh_registerà         // bcmsdio/sys/bcmsdh_linux.c</p><p>Sdio_function_inità              // bcmsdio/sys/bcmsdh_sdmmc_linux.c</p><p>Sdio_register_driverà  // bcmsdio/sys/bcmsdh_sdmmc_linux.c</p><p>Bcmsdh_sdmmc_probeà//bcmsdio/sys/bcmsdh_sdmmc_linux.c</p><p>Bcmsdh_probeà//bcmsdio/sys/bcmsdh_linux.c</p><p>Bcmsdio_probeà //dhd/sys/dhd_sdio.c</p><p>这里注意上面两个红色标记的函数，sdio_register_driver注册了一个sdio设备，在匹配成功后调用bcmsdh_sdmmc_probe函数，这个函数会调用bcmsdh_probe。这里有一点要注意：浏览bcmsdh_linux.c文件可以看出，在bcmsdh_register函数中，当定义了BCMLXSDMMC宏时，会调用sdio_function_init函数，否则调用driver_register函数：</p><p>int</p><p>bcmsdh_register(bcmsdh_driver_t*driver)</p><p>{<br>        int error = 0;</p><p> </p><p>        drvinfo = *driver; //注意这里，后面会介绍到它的用处</p><p> </p><p>#if defined(BCMPLATFORM_BUS)</p><p>#if defined(BCMLXSDMMC)</p><p>       SDLX_MSG((“Linux Kernel SDIO/MMC Driver\n”));</p><p>        error =sdio_function_init();</p><p>#else</p><p>       SDLX_MSG((“Intel PXA270 SDIO Driver\n”));</p><p>        error =driver_register(&amp;bcmsdh_driver);</p><p>#endif /* defined(BCMLXSDMMC) */</p><p>        return error;</p><p>#endif /*defined(BCMPLATFORM_BUS) */</p><p> </p><p>#if !defined(BCMPLATFORM_BUS)&amp;&amp; !defined(BCMLXSDMMC)</p><p>#if (LINUX_VERSION_CODE &lt;KERNEL_VERSION(2, 6, 0))</p><p>        if (!(error =pci_module_init(&amp;bcmsdh_pci_driver)))</p><p>                return 0;</p><p>#else</p><p>        if (!(error =pci_register_driver(&amp;bcmsdh_pci_driver)))</p><p>                return 0;</p><p>#endif</p><p> </p><p>        SDLX_MSG((“%s: pci_module_initfailed 0x%x\n”, <strong>FUNCTION</strong>, error));</p><p>#endif /* BCMPLATFORM_BUS */</p><p> </p><p>        return error;</p><p>}</p><p>上面的流程中有sdio_function_init的调用出现，所以这里实际上BCMLXSDMMC宏被定义了，bcmsdh_probe函数只是作为一个普通函数被调用，如果不定义该宏，那么bcmsdh_probe函数会被作为驱动匹配设备后第一个调用的函数而被自动调用。</p><p>再看看dhdsdio_probe函数调用的玄机，从上面的bcmsdh_register函数可以看出它的参数被传递给了drvinfo，看看bcmsdh_register的调用地方：</p><p>static bcmsdh_driver_t dhd_sdio = {</p><p>        dhdsdio_probe,</p><p>        dhdsdio_disconnect</p><p>};</p><p> </p><p>int</p><p>dhd_bus_register(void)</p><p>{<br>        DHD_TRACE((“%s: Enter\n”,<strong>FUNCTION</strong>));</p><p> </p><p>        return bcmsdh_register(&amp;dhd_sdio);</p><p>}</p><p>上面传递的参数是dhd_sdio结构变量，被用两个函数初始化了，那么哪一个是attach呢？需要找到定义bcmsdh_driver_t结构定义的地方：</p><p>Path：src/include/bcmsdh.h</p><p>/* callback functions */</p><p>typedef struct {<br>        /* attach to device */</p><p>        void *(*attach)(uint16 vend_id, uint16 dev_id, uint16 bus,uint16 slot,</p><p>                       uint16 func, uint bustype, void * regsva, osl_t * osh,</p><p>                       void * param);</p><p>        /* detach from device */</p><p>        void (*detach)(void *ch);</p><p>} bcmsdh_driver_t;</p><p>没错，就是第一个dhdsdio_probe函数，再来看看什么地方调用了这个attach函数：</p><p>Path:bcmsdio/sys/bcmsdh_linux.c</p><p> </p><p>#ifndef BCMLXSDMMC</p><p>static</p><p>#endif /* BCMLXSDMMC */</p><p>int bcmsdh_probe(struct device*dev)</p><p>{<br>……</p><p>if (!(sdhc-&gt;ch = drvinfo.attach((vendevid&gt;&gt; 16),</p><p>                                        (vendevid &amp; 0xFFFF), 0, 0, 0, 0,</p><p>                                        (void*)regs, NULL, sdh))) {<br>                SDLX_MSG((“%s: device attachfailed\n”, <strong>FUNCTION</strong>));</p><p>                goto err;</p><p>        }</p><p> </p><p>        return 0;</p><p>……</p><p>}</p><p>红色部分的函数调用是drvinfo.attach，就是上面传递过来的dhdsdio_probe函数了，仔细阅读你会发现上面那个bcmsdh_driver_t结构体定义的地方有个说明，即把该结构的成员函数当做callback函数来使用，这就是它的用意所在。</p><p>1.3.4       网络设备注册流程<br>上面是网络设备注册流程，在dhdsdio_probe函数中先后对dhd_attach和dhd_net_attach两个函数调用，dhd_attach主要用于创建和初始化dhd_info_t和net_device两个结构变量，然后调用dhd_add_if将创建的net_device变量添加到dhd_info_t变量的iflist列表中（支持多接口）。</p><p>Dhd_attach的流程如下：</p><p>dhd_pub_t *</p><p>dhd_attach(osl_t *osh, structdhd_bus *bus, uint bus_hdrlen)</p><p>{<br>        dhd_info_t *dhd = NULL;</p><p>        struct net_device *net = NULL;</p><p> </p><p>……</p><p>        /* Allocate etherdev, including spacefor private structure */</p><p>        if (!(net = alloc_etherdev(sizeof(dhd)))) {   //网络设备的创建</p><p>                DHD_ERROR((“%s: OOM -alloc_etherdev\n”, <strong>FUNCTION</strong>));</p><p>                goto fail;</p><p>        }</p><p>        dhd_state |=DHD_ATTACH_STATE_NET_ALLOC;</p><p> </p><p> </p><p>        /* Allocate primary dhd_info */</p><p>        if (!(dhd = MALLOC(osh, sizeof(dhd_info_t)))) { //dhd的创建</p><p>                DHD_ERROR((“%s: OOM -alloc dhd_info\n”, <strong>FUNCTION</strong>));</p><p>                goto fail;</p><p>        }</p><p>……</p><p>/* Set network interface name if it was provided as moduleparameter */</p><p>        if (iface_name[0]) {<br>                int len;</p><p>                char ch;</p><p>                strncpy(net-&gt;name,iface_name, IFNAMSIZ);</p><p>                net-&gt;name[IFNAMSIZ - 1] = 0;</p><p>                len = strlen(net-&gt;name);</p><p>                ch = net-&gt;name[len - 1];</p><p>                if ((ch &gt; ‘9’ || ch &lt;’0’) &amp;&amp; (len &lt; IFNAMSIZ - 2))</p><p>                        strcat(net-&gt;name,”%d”);</p><p>        }</p><p> </p><p>        if (dhd_add_if(dhd, 0, (void *)net, net-&gt;name, NULL, 0, 0)== DHD_BAD_IF)   //将前面创建的net添加到iflist列表中</p><p>                goto fail;</p><p>        dhd_state |= DHD_ATTACH_STATE_ADD_IF;</p><p>……</p><p>Memcpy(netdev_priv(net), &amp;dhd, sizeof(dhd)); //关联dhd和net</p><p> </p><p>//dhd的初始化工作</p><p>}</p><p>Dhd_add_if的添加网络接口流程：</p><p>int</p><p>dhd_add_if(dhd_info_t *dhd, int ifidx, void *handle, char *name,</p><p>        uint8 *mac_addr,uint32 flags, uint8 bssidx)</p><p>{<br>        dhd_if_t *ifp;</p><p> </p><p>        DHD_TRACE((“%s: idx %d,handle-&gt;%p\n”, <strong>FUNCTION</strong>, ifidx, handle));</p><p> </p><p>        ASSERT(dhd &amp;&amp; (ifidx &lt;DHD_MAX_IFS));</p><p> </p><p>        ifp =dhd-&gt;iflist[ifidx];</p><p>        if (ifp != NULL) {<br>                if (ifp-&gt;net != NULL) {<br>                       netif_stop_queue(ifp-&gt;net);</p><p>                       unregister_netdev(ifp-&gt;net);</p><p>                        free_netdev(ifp-&gt;net);   //如果已经存在，释放net成员</p><p>                }</p><p>        } else</p><p>                if ((ifp = MALLOC(dhd-&gt;pub.osh,sizeof(dhd_if_t))) == NULL) {</p><p>                       DHD_ERROR((“%s: OOM - dhd_if_t\n”, <strong>FUNCTION</strong>));      //否则，创建一个dhd_if_t结构变量</p><p>                        return -ENOMEM;</p><p>                }</p><p> </p><p>        memset(ifp, 0, sizeof(dhd_if_t));</p><p>        ifp-&gt;info = dhd;      //进行系列初始化，添加工作</p><p>       dhd-&gt;iflist[ifidx] = ifp;</p><p>       strncpy(ifp-&gt;name, name, IFNAMSIZ);</p><p>        ifp-&gt;name[IFNAMSIZ] = ‘\0’;</p><p>        if (mac_addr != NULL)</p><p>                memcpy(&amp;ifp-&gt;mac_addr, mac_addr,ETHER_ADDR_LEN);</p><p> </p><p>        if (handle == NULL) {<br>                ifp-&gt;state = DHD_IF_ADD;</p><p>                ifp-&gt;idx = ifidx;</p><p>                ifp-&gt;bssidx = bssidx;</p><p>               ASSERT(&amp;dhd-&gt;thr_sysioc_ctl.thr_pid &gt;= 0);</p><p>               up(&amp;dhd-&gt;thr_sysioc_ctl.sema);</p><p>        } else</p><p>                ifp-&gt;net = (struct net_device *)handle;             //handle即一个net_device变量</p><p> </p><p>        return 0;</p><p>}</p><p>这样，一个net_device网路设备就被添加到了接口管理列表中了，但是这是网路设备还没有完成初始化和注册工作，bcmsdio_probe函数随后对dhd_net_attach的调用完成了这个操作：</p><p>int</p><p>dhd_net_attach(dhd_pub_t*dhdp, int ifidx)</p><p>{<br>        dhd_info_t <em>dhd = (dhd_info_t</em>)dhdp-&gt;info;</p><p>        struct net_device *net = NULL;</p><p>        int err = 0;</p><p>        uint8 temp_addr[ETHER_ADDR_LEN] = {0x00, 0x90, 0x4c, 0x11, 0x22, 0x33 };</p><p> </p><p>        DHD_TRACE((“%s: ifidx %d\n”,<strong>FUNCTION</strong>, ifidx));</p><p> </p><p>        ASSERT(dhd &amp;&amp;dhd-&gt;iflist[ifidx]);</p><p> </p><p>        net = dhd-&gt;iflist[ifidx]-&gt;net;              //首先从刚才添加的接口列表中取出net，然后进行下面的系列初始化工作</p><p>        ASSERT(net);</p><p>//根据内核版本信息，选择对net成员函数的初始化方式，假设是2.6.30的版本</p><p>#if (LINUX_VERSION_CODE &lt;KERNEL_VERSION(2, 6, 31))</p><p>        ASSERT(!net-&gt;open);</p><p>        net-&gt;get_stats = dhd_get_stats;</p><p>        net-&gt;do_ioctl =dhd_ioctl_entry;</p><p>       net-&gt;hard_start_xmit = dhd_start_xmit;</p><p>       net-&gt;set_mac_address = dhd_set_mac_address;</p><p>       net-&gt;set_multicast_list = dhd_set_multicast_list;</p><p>        net-&gt;open =net-&gt;stop = NULL;</p><p>#else</p><p>        ASSERT(!net-&gt;netdev_ops);</p><p>        net-&gt;netdev_ops = &amp;dhd_ops_virt;</p><p>#endif</p><p> </p><p>        /* Ok, link into the network layer…*/</p><p>        if (ifidx == 0) {<br>                /*</p><p>                 * device functions for theprimary interface only</p><p>                 */</p><p>#if (LINUX_VERSION_CODE &lt;KERNEL_VERSION(2, 6, 31))</p><p>                net-&gt;open = dhd_open;</p><p>               net-&gt;stop = dhd_stop;</p><p>#else</p><p>                net-&gt;netdev_ops = &amp;dhd_ops_pri;</p><p>#endif</p><p>        } else {<br>                /*</p><p>                 * We have to use the primaryMAC for virtual interfaces</p><p>                                                                                                                          3417,1-8      66%</p><p>                 */</p><p>                memcpy(temp_addr,dhd-&gt;iflist[ifidx]-&gt;mac_addr, ETHER_ADDR_LEN);</p><p>                /*</p><p>                 * Android sets the locallyadministered bit to indicate that this is a</p><p>                 * portable hotspot.  This will not work in simultaneous AP/STAmode,</p><p>                 * nor with P2P.  Need to set the Donlge’s MAC address, andthen use that.</p><p>                 */</p><p>                if(!memcmp(temp_addr, dhd-&gt;iflist[0]-&gt;mac_addr,</p><p>                        ETHER_ADDR_LEN)) {</p><p>                        DHD_ERROR((“%sinterface [%s]: set locally administered bit in MAC\n”,</p><p>                        <strong>func</strong>,net-&gt;name));</p><p>                        temp_addr[0] |= 0x02;</p><p>                }</p><p>        }</p><p> </p><p>       net-&gt;hard_header_len = ETH_HLEN + dhd-&gt;pub.hdrlen;</p><p>#if LINUX_VERSION_CODE &gt;=KERNEL_VERSION(2, 6, 24)</p><p>        net-&gt;ethtool_ops = &amp;dhd_ethtool_ops;</p><p>#endif /* LINUX_VERSION_CODE&gt;= KERNEL_VERSION(2, 6, 24) */</p><p> </p><p>#ifdefined(CONFIG_WIRELESS_EXT)</p><p>#if WIRELESS_EXT &lt; 19</p><p>        net-&gt;get_wireless_stats = dhd_get_wireless_stats;</p><p>#endif /* WIRELESS_EXT &lt; 19*/</p><p>#if WIRELESS_EXT &gt; 12</p><p>        net-&gt;wireless_handlers = (struct iw_handler_def*)&amp;wl_iw_handler_def;   //这里的初始化工作很重要，之后的ioctl流程会涉及到对它的使用</p><p>#endif /* WIRELESS_EXT &gt; 12*/</p><p>#endif /*defined(CONFIG_WIRELESS_EXT) */</p><p> </p><p>        dhd-&gt;pub.rxsz =DBUS_RX_BUFFER_SIZE_DHD(net);</p><p>                //设置设备地址</p><p>        memcpy(net-&gt;dev_addr, temp_addr, ETHER_ADDR_LEN);</p><p> </p><p>        if ((err =register_netdev(net)) != 0) {       //注册net</p><p>                DHD_ERROR((“couldn’tregister the net device, err %d\n”, err));</p><p>                goto fail;</p><p>        }</p><p>       </p><p> </p><p>……</p><p>}</p><p>到这里net网络设备就被注册到系统中了，设备准备好了就好对设备进行访问了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WLAN驱动结构介绍&quot;&gt;&lt;a href=&quot;#WLAN驱动结构介绍&quot; class=&quot;headerlink&quot; title=&quot;WLAN驱动结构介绍&quot;&gt;&lt;/a&gt;WLAN驱动结构介绍&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;SDIO驱动&lt;br&gt;在drivers/mmc下面是mmc卡，SD</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>信号幽灵wifi（第二篇）</title>
    <link href="http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E4%BA%8C%E7%AF%87%EF%BC%89/</id>
    <published>2021-03-06T10:30:06.000Z</published>
    <updated>2021-03-06T10:36:27.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wifi模块解析和启动流程"><a href="#Wifi模块解析和启动流程" class="headerlink" title="Wifi模块解析和启动流程"></a>Wifi模块解析和启动流程</h1><ul><li>框架分析<br>WIFI整体框架如图所示：</li></ul><p>首先，用户程序使用WifiManager类来管理Wifi模块，它能够获得Wifi模块的状态，配置和控制Wifi模块，而所有这些操作都要依赖 Wifiservice类来实现。</p><p> WifiService和WifiMonitor类是Wifi框架的核心，如图所示。下面先来看看WifiService是什么时候，怎么被创建和初始化 的。</p><p> 在systemServer启动之后，它会创建一个 ConnectivityServer对象，这个对象的构造函数会创建一个WifiService的实例，代码如下所示：</p><p> </p><p>framework/base/services/java/com/android/server/ConnectivityService.java</p><p>{<br>……</p><p>case ConnectivityManager.TYPE_WIFI:</p><p>               if(DBG) Slog.v(TAG, “Starting Wifi Service.”);</p><p>               WifiStateTrackerwst = new WifiStateTracker(context,mHandler);                            //创建WifiStateTracker实例</p><p>               WifiService wifiService = newWifiService(context,wst);//创建WifiService实例</p><p>               ServiceManager.addService(Context.WIFI_SERVICE,wifiService);           //向服务管理系统添加Wifi服务</p><p>               wifiService.startWifi();    //启动Wifi</p><p>               mNetTrackers[ConnectivityManager.TYPE_WIFI]= wst;</p><p>               wst.startMonitoring(); //启动WifiMonitor中的WifiThread线程</p><p>……</p><p>}</p><p>       WifiService的主要工作：WifiMonitor和Wpa_supplicant的启动和关闭，向Wpa_supplicant发送命令。</p><p>       WifiMonitor的主要工作：阻塞监听并接收来自Wpa_supplicant的消息，然后发送给WifiStateTracker。</p><p>      上面两个线程通过AF_UNIX套接字和Wpa_supplicant通信，在通信过程中有两种连接方式：控制连接和监听连接。它们创建代码如下：</p><p>ctrl_conn =wpa_ctrl_open(ifname);</p><p>.. .. ..</p><p> monitor_conn = wpa_ctrl_open(ifname);</p><h1 id="Wifi启动流程"><a href="#Wifi启动流程" class="headerlink" title="Wifi启动流程"></a>Wifi启动流程</h1><ul><li>使能Wifi</li></ul><p>      要想使用Wifi模块，必须首先使能Wifi，当你第一次按下Wifi使能按钮时，WirelessSettings会实例化一个WifiEnabler 对象，实例化代码如下：</p><p>packages/apps/settings/src/com/android/settings/WirelessSettings.java</p><p>protected void onCreate(Bundle savedInstanceState) {<br>       super.onCreate(savedInstanceState);</p><p>……</p><p>             CheckBoxPreferencewifi = (CheckBoxPreference) findPreference(KEY_TOGGLE_WIFI);</p><p>             mWifiEnabler=new WifiEnabler(this, wifi);</p><p>……</p><p>}</p><p>       WifiEnabler类的定义大致如下，它实现了一个监听接口，当WifiEnabler对象被初始化后，它监听到你按键的动作，会调用响应函数 onPreferenceChange（），这个函数会调用WifiManager的setWifiEnabled（）函数。</p><p>public class WifiEnabler implementsPreference.OnPreferenceChangeListener{<br>……</p><p>public boolean onPreferenceChange(Preference preference,Objectvalue) {<br>        booleanenable = (Boolean)value;</p><p>……</p><p>if (mWifiManager.setWifiEnabled(enable)) {<br>               mCheckBox.setEnabled(false);</p><p>……</p><p>}</p><p>……</p><p>}</p><p>       我们都知道Wifimanager只是个服务代理，所以它会调用WifiService的setWifiEnabled（）函数，而这个函数会调用 sendEnableMessage（）函数，了解android消息处理机制的都知道，这个函数最终会给自己发送一个 MESSAGE_ENABLE_WIFI的消息，被WifiService里面定义的handlermessage()函数处理，会调用 setWifiEnabledBlocking（）函数。下面是调用流程：</p><p>mWifiEnabler.onpreferencechange()=&gt;mWifiManage.setWifienabled()=&gt;mWifiService.setWifiEnabled()=&gt;mWifiService.sendEnableMessage()=&gt;mWifiService.handleMessage()=&gt;mWifiService.setWifiEnabledBlocking().</p><p>在 setWifiEnabledBlocking()函数中主要做如下工作：加载Wifi驱动，启动wpa_supplicant，注册广播接收器，启动 WifiThread监听线程。代码如下：</p><p>……</p><p>if (enable) {<br>           if(!mWifiStateTracker.loadDriver()) {<br>               Slog.e(TAG,”Failed toload Wi-Fi driver.”);</p><p>               setWifiEnabledState(WIFI_STATE_UNKNOWN,uid);</p><p>               return false;</p><p>           }</p><p>           if(!mWifiStateTracker.startSupplicant()) {<br>               mWifiStateTracker.unloadDriver();</p><p>               Slog.e(TAG, “Failed tostart supplicant daemon.”);</p><p>               setWifiEnabledState(WIFI_STATE_UNKNOWN, uid);</p><p>               return false;</p><p>           }</p><p> </p><p>           registerForBroadcasts();</p><p>           mWifiStateTracker.startEventLoop();</p><p>……</p><p> 至此，Wifi使能结束，自动进入扫描阶段。</p><h1 id="扫描AP"><a href="#扫描AP" class="headerlink" title="扫描AP"></a>扫描AP</h1><p>      当驱动加载成功后，如果配置文件的AP_SCAN = 1，扫描会自动开始，WifiMonitor将会从supplicant收到一个消息EVENT_DRIVER_STATE_CHANGED，调用 handleDriverEvent（），然后调用mWifiStateTracker.notifyDriverStarted()，该函数向消息队列 添加EVENT_DRIVER_STATE_CHANGED，handlermessage()函数处理消息时调用scan()函数，并通过 WifiNative将扫描命令发送到wpa_supplicant。</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiMonitor.java</p><p>private void handleDriverEvent(Stringstate) {<br>           if(state == null) {<br>               return;</p><p>           }</p><p>           if(state.equals(“STOPPED”)) {<br>               mWifiStateTracker.notifyDriverStopped();</p><p>           }else if (state.equals(“STARTED”)) {<br>               mWifiStateTracker.notifyDriverStarted();</p><p>           }else if (state.equals(“HANGED”)) {<br>               mWifiStateTracker.notifyDriverHung();</p><p>           }</p><p>       }</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiStateTracker.java</p><p>case EVENT_DRIVER_STATE_CHANGED:</p><p>        </p><p>               switch(msg.arg1) {<br>               case DRIVER_STARTED:</p><p>                   /**</p><p>                    *Set the number of allowed radio channels according</p><p>                    *to the system setting, since it gets reset by the</p><p>                    *driver upon changing to the STARTED state.</p><p>                    */</p><p>                   setNumAllowedChannels();</p><p>                   synchronized(this) {<br>                       if(mRunState == RUN_STATE_STARTING) {<br>                           mRunState= RUN_STATE_RUNNING;</p><p>                           if(!mIsScanOnly) {<br>                               reconnectCommand();</p><p>                           }else {<br>                               // In somesituations, supplicant needs to be kickstarted to</p><p>                               // start thebackground scanning</p><p>                               scan(true);</p><p>                           }</p><p>                       }</p><p>                   }</p><p>                   break;             </p><p>上面是启动Wifi 时，自动进行的AP的扫描，用户当然也可以手动扫描AP，这部分实现在WifiService里面，WifiService通过startScan()接 口函数发送扫描命令到supplicant。</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiStateTracker.java</p><p>public boolean startScan(booleanforceActive) {<br>       enforceChangePermission();</p><p> </p><p>       switch(mWifiStateTracker.getSupplicantState()) {<br>           caseDISCONNECTED:</p><p>           caseINACTIVE:</p><p>           caseSCANNING:</p><p>           caseDORMANT:</p><p>               break;</p><p>           default:</p><p>               mWifiStateTracker.setScanResultHandling(</p><p>                       WifiStateTracker.SUPPL_SCAN_HANDLING_LIST_ONLY);</p><p>               break;</p><p>       }</p><p>       return mWifiStateTracker.scan(forceActive);</p><p>    }</p><p>       然后下面的流程同上面的自动扫描，我们来分析一下手动扫描从哪里开始的。我们应该知道手动扫描是通过菜单键的扫描键来响应的，而响应该动作的应该是 WifiSettings类中Scanner类的handlerMessage()函数，它调用WifiManager的 startScanActive()，这才调用WifiService的startScan()。</p><p>packages/apps/Settings/src/com/android/settings/wifiwifisettings.java</p><p>public boolean onCreateOptionsMenu(Menu menu) {<br>       menu.add(Menu.NONE,MENU_ID_SCAN, 0, R.string.wifi_menu_scan)</p><p>               .setIcon(R.drawable.ic_menu_scan_network);</p><p>       menu.add(Menu.NONE,MENU_ID_ADVANCED, 0, R.string.wifi_menu_advanced)</p><p>               .setIcon(android.R.drawable.ic_menu_manage);</p><p>       returnsuper.onCreateOptionsMenu(menu);</p><p>    }</p><p>       当按下菜单键时，WifiSettings就会调用这个函数绘制菜单。如果选择扫描按钮，WifiSettings会调用 onOptionsItemSelected()。</p><p>packages/apps/Settings/src/com/android/settings/wifiwifisettings.java</p><p>public booleanonOptionsItemSelected(MenuItem item) {<br>       switch (item.getItemId()){<br>           caseMENU_ID_SCAN:</p><p>               if(mWifiManager.isWifiEnabled()) {<br>                   mScanner.resume();</p><p>               }</p><p>               return true;</p><p>           caseMENU_ID_ADVANCED:</p><p>               startActivity(new Intent(this,AdvancedSettings.class));</p><p>               return true;</p><p>       }</p><p>       returnsuper.onOptionsItemSelected(item);</p><p>}</p><p> </p><p>private class Scanner extends Handler {<br>       private int mRetry = 0;</p><p> </p><p>       void resume() {<br>           if (!hasMessages(0)) {</p><p>               sendEmptyMessage(0);</p><p>           }</p><p>       }</p><p> </p><p>       void pause() {<br>           mRetry= 0;</p><p>           mAccessPoints.setProgress(false);</p><p>           removeMessages(0);</p><p>       }</p><p> </p><p>       @Override</p><p>       public voidhandleMessage(Message message) {<br>           if(mWifiManager.startScanActive()){<br>               mRetry = 0;</p><p>           }else if (++mRetry &gt;= 3) {<br>               mRetry = 0;</p><p>               Toast.makeText(WifiSettings.this,R.string.wifi_fail_to_scan,</p><p>                       Toast.LENGTH_LONG).show();</p><p>               return;</p><p>           }</p><p>           mAccessPoints.setProgress(mRetry!= 0);</p><p>           sendEmptyMessageDelayed(0, 6000);</p><p>       }</p><p>    }</p><p>这里的mWifiManager.startScanActive()就会调用WifiService里 的startScan（）函数，下面的流程和上面的一样，这里不赘述。</p><p>当supplicant完成了这个扫描命令后，它会发送一个消息给上 层，提醒他们扫描已经完成，WifiMonitor会接收到这消息，然后再发送给WifiStateTracker。</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiMonitor.java</p><p>void handleEvent(int event, String remainder) {<br>           switch (event) {<br>               caseDISCONNECTED:</p><p>                   handleNetworkStateChange(NetworkInfo.DetailedState.DISCONNECTED,remainder);</p><p>                   break;</p><p> </p><p>               case CONNECTED:</p><p>                   handleNetworkStateChange(NetworkInfo.DetailedState.CONNECTED,remainder);</p><p>                   break;</p><p> </p><p>               case SCAN_RESULTS:</p><p>                   mWifiStateTracker.notifyScanResultsAvailable();</p><p>                   break;</p><p> </p><p>               case UNKNOWN:</p><p>                   break;</p><p>            }</p><p>        }</p><p>WifiStateTracker将会广播SCAN_RESULTS_AVAILABLE_ACTION消息：</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiStateTracker.java</p><p>public voidhandleMessage(Message msg) {<br>        Intent intent;</p><p>……</p><p>case EVENT_SCAN_RESULTS_AVAILABLE:</p><p>               if(ActivityManagerNative.isSystemReady()) {<br>                   mContext.sendBroadcast(newIntent(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION));</p><p>               }</p><p>               sendScanResultsAvailable();</p><p>               /**</p><p>                * On receiving the first scanresults after connecting to</p><p>                * the supplicant, switch scanmode over to passive.</p><p>                */</p><p>               setScanMode(false);</p><p>               break;</p><p>……</p><p>｝</p><p>       由于WifiSettings类注册了intent，能够处理SCAN_RESULTS_AVAILABLE_ACTION消息，它会调用 handleEvent()，调用流程如下所示。</p><p>WifiSettings.handleEvent()=&gt;WifiSettings.updateAccessPoints() =&gt; mWifiManager.getScanResults()=&gt; mService.getScanResults()=&gt; mWifiStateTracker.scanResults() =&gt;WifiNative.scanResultsCommand()……</p><p>将 获取AP列表的命令发送到supplicant，然后supplicant通过Socket发送扫描结果，由上层接收并显示。这和前面的消息获取流程基本 相同。</p><h1 id="配置，连接AP"><a href="#配置，连接AP" class="headerlink" title="配置，连接AP"></a>配置，连接AP</h1><p>当用户选择一个活跃的AP时，WifiSettings响应打开一个对话框来配 置AP，比如加密方法和连接AP的验证模式。配置好AP后，WifiService添加或更新网络连接到特定的AP。</p><p>packages/apps/settings/src/com/android/settings/wifi/WifiSetttings.java</p><p>public booleanonPreferenceTreeClick(PreferenceScreen screen,Preference preference) {<br>       if (preference instanceofAccessPoint) {<br>           mSelected= (AccessPoint) preference;</p><p>           showDialog(mSelected, false);</p><p>       } else if (preference ==mAddNetwork) {<br>           mSelected= null;</p><p>           showDialog(null,true);</p><p>       } else if (preference ==mNotifyOpenNetworks) {<br>           Secure.putInt(getContentResolver(),</p><p>                   Secure.WIFI_NETWORKS_AVAILABLE_NOTIFICATION_ON,</p><p>                   mNotifyOpenNetworks.isChecked()? 1 : 0);</p><p>       } else {<br>           returnsuper.onPreferenceTreeClick(screen, preference);</p><p>       }</p><p>       return true;</p><p>    }</p><p>       配置好以后，当按下“Connect Press”时，WifiSettings通过发送LIST_NETWORK命令到supplicant来检查该网络是否配置。如果没有该网络或没有配置 它，WifiService调用addorUpdateNetwork（）函数来添加或更新网络，然后发送命令给supplicant，连接到这个网络。 下面是从响应连接按钮到WifiService发送连接命令的代码：</p><p>packages/apps/settings/src/com/android/settings/wifi/WifiSetttings.java</p><p>public void onClick(DialogInterfacedialogInterface, int button) {<br>       if (button ==WifiDialog.BUTTON_FORGET &amp;&amp; mSelected != null) {<br>           forget(mSelected.networkId);</p><p>       } else if (button ==WifiDialog.BUTTON_SUBMIT &amp;&amp; mDialog !=null) {<br>           WifiConfigurationconfig = mDialog.getConfig();</p><p> </p><p>           if(config == null) {<br>               if (mSelected != null&amp;&amp; !requireKeyStore(mSelected.getConfig())) {<br>                   connect(mSelected.networkId);</p><p>               }</p><p>           }else if (config.networkId != -1) {<br>               if (mSelected != null) {<br>                   mWifiManager.updateNetwork(config);</p><p>                   saveNetworks();</p><p>               }</p><p>           }else {<br>               intnetworkId =mWifiManager.addNetwork(config);</p><p>               if (networkId != -1) {<br>                   mWifiManager.enableNetwork(networkId,false);</p><p>                   config.networkId =networkId;</p><p>                   if (mDialog.edit || requireKeyStore(config)){<br>                       saveNetworks();</p><p>                   } else {<br>                       connect(networkId);</p><p>                   }</p><p>               }</p><p>           }</p><p>       }</p><p>    }</p><p>Frameworks\base\wifi\java\android\net\wifi\WifiManager.java</p><p>public intupdateNetwork(WifiConfiguration config) {<br>        if(config == null ||config.networkId &lt; 0) {<br>           return-1;</p><p>        }</p><p>        returnaddOrUpdateNetwork(config);</p><p>}</p><p>private intaddOrUpdateNetwork(WifiConfiguration config) {<br>       try {<br>           return mService.addOrUpdateNetwork(config);</p><p>       } catch (RemoteExceptione) {<br>           return-1;</p><p>       }</p><p>    }</p><p> </p><p>WifiService.addOrUpdateNetwork()通过调用mWifiStateTracker.setNetworkVariable()将连接命令发送到Wpa_supplicant。</p><h1 id="获取IP地址"><a href="#获取IP地址" class="headerlink" title="获取IP地址"></a>获取IP地址</h1><p>当连接到supplicant后，WifiMonitor就会通知WifiStateTracker。</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiMonitor.java</p><p>Public void Run(){<br>if (connectToSupplicant()) {<br>               // Send a message indicatingthat it is now possible to send commands</p><p>               // tothe supplicant</p><p>               mWifiStateTracker.notifySupplicantConnection();</p><p>           }else {<br>               mWifiStateTracker.notifySupplicantLost();</p><p>               return;</p><p>           }</p><p>……</p><p>}</p><p>WifiStateTracker 发送EVENT_SUPPLICANT_CONNECTION消息到消息队列，这个消息有自己的handlermessage()函数处理，它会启动一个 DHCP线程，而这个线程会一直等待一个消息事件，来启动DHCP协议分配IP地址。</p><p>frameworks/base/wifi/java/android/net/wifi/WifiStateTracker.java</p><p>void notifySupplicantConnection() {<br>       sendEmptyMessage(EVENT_SUPPLICANT_CONNECTION);</p><p>}</p><p> </p><p>public void handleMessage(Message msg) {<br>       Intent intent;</p><p> </p><p>       switch (msg.what) {<br>           caseEVENT_SUPPLICANT_CONNECTION:</p><p>            ……</p><p>            HandlerThread dhcpThread =newHandlerThread(“DHCP Handler Thread”);</p><p>               dhcpThread.start();</p><p>               mDhcpTarget =newDhcpHandler(dhcpThread.getLooper(), this);</p><p>……</p><p>……</p><p>}</p><p>当 Wpa_supplicant连接到AP后，它会发送一个消息给上层来通知连接成功，WifiMonitor会接受到这个消息并上报给 WifiStateTracker。</p><p>Frameworks/base/wifi/java/android/net/wifi/WifiMonitor.java</p><p>void handleEvent(int event, String remainder) {<br>           switch(event) {<br>               caseDISCONNECTED:</p><p>                   handleNetworkStateChange(NetworkInfo.DetailedState.DISCONNECTED,remainder);</p><p>                   break;</p><p> </p><p>               caseCONNECTED:</p><p>                   handleNetworkStateChange(NetworkInfo.DetailedState.CONNECTED,remainder);</p><p>                   break;</p><p>               ……</p><p>}</p><p> </p><p>private void handleNetworkStateChange(NetworkInfo.DetailedStatenewState, String data) {<br>        StringBSSID = null;</p><p>        intnetworkId = -1;</p><p>        if(newState ==NetworkInfo.DetailedState.CONNECTED) {<br>           Matchermatch = mConnectedEventPattern.matcher(data);</p><p>           if(!match.find()) {<br>               if(Config.LOGD) Log.d(TAG, “Could not find BSSID in CONNECTEDeventstring”);</p><p>           }else {<br>               BSSID= match.group(1);</p><p>               try{<br>                   networkId= Integer.parseInt(match.group(2));</p><p>               }catch (NumberFormatException e) {<br>                   networkId= -1;</p><p>               }</p><p>            }</p><p>        }</p><p>        mWifiStateTracker.notifyStateChange(newState,BSSID,networkId);</p><p>}</p><p>      </p><p>void notifyStateChange(DetailedState newState, StringBSSID, intnetworkId) {<br>        Messagemsg =Message.obtain(</p><p>           this,EVENT_NETWORK_STATE_CHANGED,</p><p>           newNetworkStateChangeResult(newState, BSSID, networkId));</p><p>       msg.sendToTarget();</p><p>    }</p><p> </p><p>caseEVENT_NETWORK_STATE_CHANGED:</p><p>……</p><p>configureInterface();</p><p>……</p><p> </p><p>private void configureInterface() {<br>       checkPollTimer();</p><p>        mLastSignalLevel = -1;</p><p>        if(!mUseStaticIp){          //使用DHCP线程动态IP</p><p>           if(!mHaveIpAddress &amp;&amp; !mObtainingIpAddress) {<br>               mObtainingIpAddress= true;</p><p> </p><p>                                  //发送启动DHCP线程获取IP</p><p>               mDhcpTarget.sendEmptyMessage(EVENT_DHCP_START);</p><p>            }</p><p>        } else{        //使用静态IP，IP信息从mDhcpInfo中获取</p><p>           intevent;</p><p>           if(NetworkUtils.configureInterface(mInterfaceName,mDhcpInfo)) {<br>               mHaveIpAddress= true;</p><p>               event= EVENT_INTERFACE_CONFIGURATION_SUCCEEDED;</p><p>               if(LOCAL_LOGD) Log.v(TAG, “Static IP configurationsucceeded”);</p><p>           }else {<br>               mHaveIpAddress= false;</p><p>               event= EVENT_INTERFACE_CONFIGURATION_FAILED;</p><p>               if(LOCAL_LOGD) Log.v(TAG, “Static IP configuration failed”);</p><p>            }</p><p>           sendEmptyMessage(event);          //发送IP获得成功消息事件</p><p>        }</p><p>    }</p><p>             DhcpThread获取EVENT_DHCP_START消息事件后，调用handleMessage（）函数，启动DHCP获取IP地址的服务。</p><p>public void handleMessage(Message msg) {<br>           intevent;</p><p>switch (msg.what) {<br>               caseEVENT_DHCP_START:</p><p> </p><p>……</p><p>Log.d(TAG, “DhcpHandler: DHCP requeststarted”);</p><p>//启动一个DHCPclient的精灵进 程，为mInterfaceName请求分配一个IP地//址</p><p>    if (NetworkUtils.runDhcp(mInterfaceName, mDhcpInfo)) {<br>     event=EVENT_INTERFACE_CONFIGURATION_SUCCEEDED;</p><p>         if(LOCAL_LOGD)Log.v(TAG, “DhcpHandler: DHCP request succeeded”);</p><p>    } else {<br>           event=EVENT_INTERFACE_CONFIGURATION_FAILED;</p><p>          Log.i(TAG,”DhcpHandler: DHCP request failed: “ +</p><p>                           NetworkUtils.getDhcpError());</p><p>        }</p><p>……</p><p>}</p><p>这 里调用了一个NetworkUtils.runDhcp（）函数，NetworkUtils类是一个网络服务的辅助类，它主要定义了一些本地接口，这些接 口会通过他们的JNI层android_net_NetUtils.cpp文件和DHCP client通信，并获取IP地址。</p><p>至此，IP 地址获取完毕，Wifi启动流程结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Wifi模块解析和启动流程&quot;&gt;&lt;a href=&quot;#Wifi模块解析和启动流程&quot; class=&quot;headerlink&quot; title=&quot;Wifi模块解析和启动流程&quot;&gt;&lt;/a&gt;Wifi模块解析和启动流程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;框架分析&lt;br&gt;WIFI整体框架如图所示</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>信号幽灵wifi（第一篇）</title>
    <link href="http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/"/>
    <id>http://example.com/2021/03/06/%E4%BF%A1%E5%8F%B7%E5%B9%BD%E7%81%B5wifi%EF%BC%88%E7%AC%AC%E4%B8%80%E7%AF%87%EF%BC%89/</id>
    <published>2021-03-06T10:22:01.000Z</published>
    <updated>2021-03-06T11:25:05.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WLAN技术"><a href="#WLAN技术" class="headerlink" title="WLAN技术"></a>WLAN技术</h1><p>WLAN是英文WirelessLAN的缩写，就是无线局域网的意思。无线以太网技术是一种基于无线传输的局域网技术，与有线网络技术相比，具有灵活、建网迅速、个人化等特点。将这一技术应用于电信网的接入网领域，能够方便、灵活地为用户提供网络接入，适合于用户流动性较大、有数据业务需求的公共场所、高端的企业及家庭用户、需要临时建网的场合以及难以采用有线接入方式的环境等。</p><h1 id="802-11协议简述"><a href="#802-11协议简述" class="headerlink" title="802.11协议简述"></a>802.11协议简述</h1><ul><li>概述<br>作为全球公认的局域网权威，IEEE802工作组建立的标准在过去二十年内在局域网领域独领风骚。这些协议包括了802.3Ethernet协议、802.5TokenRing协议、802.3z100BASE－T快速以太网协议。在1997年，经过了7年的工作以后，IEEE发布了802.11协议，这也是在无线局域网领域内的第一个国际上被认可的协议。</li></ul><p>在1999年9月，他们又提出了802.11b”HighRate”协议，用来对802.11协议进行补充，802.11b在802.11的1Mbps和2Mbps速率下又增加了5.5Mbps和11Mbps两个新的网络吞吐速率。利用802.11b，移动用户能够获得同Ethernet一样的性能、网络吞吐率、可用性。这个基于标准的技术使得管理员可以根据环境选择合适的局域网技术来构造自己的网络，满足他们的商业用户和其他用户的需求。802.11协议主要工作在ISO协议的最低两层上，并在物理层上进行了一些改动，加入了高速数字传输的特性和连接的稳定性。</p><p>主要内容：<br>　　1.802.11工作方式<br>　　2.802.11物理层<br>　　3.802.11b的增强物理层<br>　　4.802.11数字链路层<br>　　5.联合结构、蜂窝结构和漫游</p><h1 id="802-11四种主要物理组件"><a href="#802-11四种主要物理组件" class="headerlink" title="802.11四种主要物理组件"></a>802.11四种主要物理组件</h1><ul><li><p>工作站（Station）<br>构建网络的主要目的是为了在工作站间传送数据。所谓工作站，是指配备无线网络接口的计算设备。</p></li><li><p>接入点（Access Point）</p></li></ul><p>802.11网络所使用的帧必须经过转换，方能被传递至其他不同类型的网络。具备无线至有线的桥接功能的设备称为接入点，接入点的功能不仅于此，但桥接最为重要。</p><ul><li>无线媒介（Wireless Medium）</li></ul><p>802.11标准以无线媒介在工作站之间传递帧。其所定义的物理层不只是一种，802.11最初标准化了两种射频物理层以及一种红外线物理层。</p><ul><li>分布式系统（Distribution System）<br>当几个接入点串联以覆盖较大区域时，彼此之间必须相互通信以掌握移动式工作站的行踪。分布式系统属于802.11的逻辑组件，负责将帧转送至目的地。</li></ul><p>下图为802.11网络的基本服务集（basic service set），其中包含了这四种物理组件。</p><h1 id="WIFI适配层"><a href="#WIFI适配层" class="headerlink" title="WIFI适配层"></a>WIFI适配层</h1><p>里面定义很多字符串变量和适配层的接口实现，是对wpa_supplicant程序通信的接口封装，用来完成上层和wpa_supplicant的通信， 头文件在libhardware/include/hardware下，这里的函数用来向JNI的本地实现提供调用接口。</p><p>这里的函数，我把它们分为四类函数：</p><p>一类是命令相关的（控制）函数，就是在JNI层android_XXX_Command()函数所调用 的Wifi_Command()函数，调用流程如下：</p><p>android_XXX_command()=&gt;docommand()=&gt;wifi_command()=&gt;wifi_send_command()=&gt;wpa_ctrl_require()</p><p>二类是 监听函数，即Wifi_wait_for_event()函数，调用流程如下：android_net_wifi_Waitforevent()=&gt;wifi_wait_for_event()=&gt;wpa_ctrl_recv()</p><p>三就是WPA_SUPPLICANT的启动，连接，关闭函数</p><p>四是驱动的加载和卸载函数</p><h1 id="wpa-supplicant"><a href="#wpa-supplicant" class="headerlink" title="wpa_supplicant"></a>wpa_supplicant</h1><ul><li>wpa_ctrl的作用<br>定义了两类套接字和一个管道，并分别实现了和wpa_supplicant的通信，而在实际的实现中采用的都是套接字的方式，因此wpa_supplicant适配层和wpa_supplicant层 是通过socket通讯的。</li></ul><p>要是从wifi.c中真的很难看出它和wpa_supplicant有什么关系，和它联系密切的就是 这个wpa_ctrl.h文件，这里面定义了一个类wpa_ctrl，这个类中声明了两个Socket套接口，一个是本地一个是要连接的套接 口，wpa_ctrl与wpa_supplicant的通信就需要socket来帮忙了，而wpa_supplicant就是通过调用 wpa_ctrl.h中定义的函数和wpa_supplicant进行通讯的，wpa_ctrl类（其实是其中的两个socket）就是他们之间的桥梁。</p><h1 id="WPA-SUPPLICANT"><a href="#WPA-SUPPLICANT" class="headerlink" title="WPA_SUPPLICANT"></a>WPA_SUPPLICANT</h1><ul><li><p>概念<br>wpa_supplicant本是开源项目源码，被谷歌修改后加入android移动平台，它主要是用来支持WEP，WPA/WPA2和WAPI无线协议和加密认证的，而实际上的工作内容是通过socket（不管是wpa_supplicant与上层还是wpa_supplicant与驱动都采用socket通讯）与驱动交互上报数据给用户，而用户可以通过socket发送命令给wpa_supplicant调动驱动来对WiFi芯片操作。 简单的说，wpa_supplicant就是WiFi驱动和用户的中转站外加对协议和加密认证的支持。</p></li><li><p>Wpa_supplicant与驱动的交互</p></li><li><p>wpa_supplicant.c<br>首先定义一个驱动操作数组externstructwpa_driver_ops *wpa_supplicant_drivers[]，然后是系列wpa_supplicant_XXX()函数，很多函数里面调用 wpa_drv_XXX()函数，这些函数是wpa_supplicant_i.h中实现的函数。几乎每个函数都需要一个wpa_supplicant结 构，对其进行所有的控制和通信操作。</p></li><li><p>Wpa_supplicant_i.h<br>其中定义了一个重要数据结构wpa_supplicant，其中有一个重要的driver成 员，它是wpa_driver_ops类型，可以被用来调用抽象层的接口。接下来是系列函数声明，这些函数声明在wpa_supplicant.c中实现，然后就是wpa_drv_XXX函数，这些函数就是在 wpa_supplicant.c中被wpa_supplicant_xxx函数调用的，而这些wpa_drv_xxx函数也都有一个 wpa_supplicant结构的变量指针，用来调用封装的抽象接口，而这些抽象接口的实现在driver_wext.c中（如果使用的汉斯WEXT驱动）。</p></li></ul><p>这里要注意的是：在wpa_suppliant.c文件中定义的很多函数是在该头文件中声明的，而不是在wpa_supplicant.h中声明的。</p><ul><li> Driver_wext.c<br>对wpa_drvier_ops的个函数的具体实现，该结构指针在wpa_supplicant注册一个网络接口时会被初始化赋予指定的操作指针，wpa_supplicant.c中的wpa_supplicant_xxx函数通过wpa_supplicant结构中的该操作指针调用WEXT的实现接口。</li></ul><p>就是在该文件中，创建了三个socket：ioctrl_socket，event_socket和mlme_socket，它们分别有自己的用途，如ioctrl_socket用于发送控制命令，event_socket用于监听驱动传来的event事件等。Wpa_supplicant通过这三个socket与wifi驱动关联，这里的socket同fd（文件描述符）类似。</p><h1 id="Wpa-cli调试工具"><a href="#Wpa-cli调试工具" class="headerlink" title="Wpa_cli调试工具"></a>Wpa_cli调试工具</h1><ul><li>启动wpa_supplicant<br>使用下面命令启动wpa_supplicant:</li></ul><p>       wpa_supplicant-Dwext -iwlan0 -C/data/system/wpa_supplicant-c/data/misc/wifi/wpa_supplicant.conf</p><p> 为了确保wpa_supplicant真的启动起来了，使用“ps”命令查看。</p><ul><li>连接wpa_cli到wpa_supplicant<br>       wpa_cli-p/data/system/wpa_supplicant -iwlan0</li></ul><p>      然后，就可以使用wpa_cli调试工具进行wifi调试了，下面列出了一些常用的调试命令：</p><p>      &gt;scan                            //扫描周围的AP</p><p>      &gt;scan_results        //显示扫描结果</p><p>      &gt;status                   //显示当前的连接状态信息</p><p>      &gt;terminate             //终止wpa_supplicant</p><p>      &gt;quit                        //退出wpa_cli</p><p>      &gt;add_network       //返回可用network id</p><p>      &gt;set_network<network id> <variable> <value> //设置网络</p><p>      &gt;select_network<network id>          //选择网络，禁用其它网络</p><p>      &gt;disable_network<network id>  //禁用网络</p><p>      &gt;enable_network<network id>        //启用网络</p><ul><li>示例</li><li>无密钥认证AP<br>             &gt;add_network      (返回可用networkid, 假定返回0)</li></ul><p>             &gt;set_network 0 ssid “666”</p><p>             &gt;set_network 0 key_mgmt NONE</p><p>             &gt;enable_network 0</p><p>             &gt;quit</p><p>如果上面的操作正确，我们会连接到一个AP，它的SSID为“666”，现在需要一个IP来访问internet：</p><p>             dhcpcd wlan0</p><p>成功获取IP后，即可连上internet。</p><ul><li>WEP认证AP<br>             &gt;add_network      (假设返回1)</li></ul><p>             &gt;set_network 1 ssid “666”</p><p>             &gt;set_network 1 key_mgmt NONE</p><p>             &gt;set_network 1 wep_key0 “ap passwork”</p><p>             &gt;set_network 1 wep_tx_keyidx 0</p><p>             &gt;select_network 1     （如果你已经连上了其它的AP，那么就需要这个命令来禁用其它的网络）</p><p>             &gt;enable_network 1</p><p>       然后同上获取IP，连接到internet上。</p><ul><li>WPA-PSK/WPA2-PSK认证AP<br>             &gt;add_network      (假定返回2)</li></ul><p>             &gt;set_network 2 ssid “666”</p><p>             &gt;set_network 2 psk “your pre-shared key”</p><p>             &gt;select_network 2 </p><p>             &gt;enable_network 2</p><p>还有其它的命令进一步设置网络，不过wpa_supplicant已经给了我们一些默认的配置。</p><ul><li> 隐藏藏AP<br>  原则上应该只要在上面的基础上去set_network netid scan_ssid 1即可，测试过无加密的Hidden AP，WEP/WPA/WPA2应该道理一样。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WLAN技术&quot;&gt;&lt;a href=&quot;#WLAN技术&quot; class=&quot;headerlink&quot; title=&quot;WLAN技术&quot;&gt;&lt;/a&gt;WLAN技术&lt;/h1&gt;&lt;p&gt;WLAN是英文WirelessLAN的缩写，就是无线局域网的意思。无线以太网技术是一种基于无线传输的局域网技</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>CT基本概念</title>
    <link href="http://example.com/2021/03/05/CT%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://example.com/2021/03/05/CT%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2021-03-05T15:16:03.000Z</published>
    <updated>2021-03-05T15:25:08.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="像素（Pixel）和体素（Voxel）"><a href="#像素（Pixel）和体素（Voxel）" class="headerlink" title="像素（Pixel）和体素（Voxel）"></a>像素（Pixel）和体素（Voxel）</h1><p>像素（Pixel）是构成图像的基本单位，即图像可被分解成的最小的独立信息单元。因为图像是二维的，所以像素也是没有“厚度”概念的，其最大特点就是一个二维的概念。体素（Voxel）是指像素所对应的体积单位，与像素不同点在于，体素是一个三维的概念，是有厚度差别的，图像所对应的层厚就是体素的“高度”。</p><h1 id="矩阵（Matrix）"><a href="#矩阵（Matrix）" class="headerlink" title="矩阵（Matrix）"></a>矩阵（Matrix）</h1><p>每幅图像都有数目不同的像素所构成，像素的多少通常用矩阵来表示，它是指构成图像的矩形面积内每一行和每一列的像素数目，如256<em>256，512</em>512等。在视野大小相同情况下，矩阵数目越大，像素就越小，图像则越清晰。</p><p>CT图像矩阵的数目在行和列的两个方向上常是相同的，但在其他类型图像中也可以不同，如192*256的图像矩阵也是可以的。</p><h1 id="CT值（CT-value）"><a href="#CT值（CT-value）" class="headerlink" title="CT值（CT value）"></a>CT值（CT value）</h1><p>由CT的原理已经知道，不同各种组织对X线有不同的衰减系数μ。但是在临床使用中，为了比较方便，不直接使用衰减系数而是采用不同组织相对于水的衰减系数的比值关系。对于组织M的CT值的计算公式如下：<br><img src="/images/25.png"> </p><p><img src="/images/26.png"> </p><p>通过上表可以看出，组织密度越大，CT值越高。通过CT值，我们可以量化组织的X线吸收系数，反映不同组织的密度差别；一旦某种组织发生病变，可以通过病变CT值的测量，辅助判断病变成分与性质。但需要指出的是，CT值并不是恒定不变的，会因X线硬化、电源状况、扫描参数、温度和邻近组织等因素发生改变，因此要在诊断中做出合理的判断。<br><img src="/images/27.png"> </p><h1 id="窗宽（Window-Width-WW）和窗位（Window-Level-WL）"><a href="#窗宽（Window-Width-WW）和窗位（Window-Level-WL）" class="headerlink" title="窗宽（Window Width, WW）和窗位（Window Level, WL）"></a>窗宽（Window Width, WW）和窗位（Window Level, WL）</h1><p>通过CT值的概念，已经知道人体组织的密度差别较大：肺部含有大量的空气，CT值接近-1000；骨骼含有密度很高的矿物质，最高的CT值接近+1000，这样CT值的变化范围仅不计小数点以下，就有2000个HU的变化（图1-14）。人眼所能够分辨的显示器上的灰阶变化大致在128个左右。为了提高对较小密度差别间组织的分辨能力，在CT图像的显示过程中引入了窗技术，即通过窗位和窗宽的设置，有针对性地观察特定的部位和组织，突出感兴趣结构在图像中的对比和层次。 </p><p>窗宽（WW）是指为最佳地显示所感兴趣结构而设置的CT值范围，该范围上下的CT值均以完全白或黑的色调显示，即该范围以外的CT值差别在图像上将无法显示。窗宽范围的中点即所谓的窗位（WL），通常它应是对应于最佳显示兴趣结构的CT值，用来设置为窗宽的中心。例如，脑实质的CT值约为35HU左右，大多数颅内病变CT值的变化在 -30至 +100HU范围内。所以头窗的窗位选择在35<del>40HU，窗宽范围选择在80</del>100HU左右（具体数值会因设备和习惯不同稍有差别），这样的头窗设置有利于脑实质的观察。而对于颅骨的观察，就要选择骨窗，窗位700 HU，窗宽2000 HU左右。 </p><p>在CT图像中，若减小窗宽范围，会突出不同组织间的差别，图像的反差加大，但看起来较粗糙。这样做的好处是，密度差较小的病灶由于增大反差变得容易发现，如在肝脏的检查中，可适当减小窗宽有利于较低密度差别病灶的检出；而另一方面，如果加大窗宽，图像的反差会减小，层次会丰富些，图像看起来较柔和，但是密度差别较小的病灶不易观察。在腹部CT检查时，适当放宽窗位，则可以使腹部的脂肪和气体的密度有所区别。在临床工作中，应根据具体的情况，恰当地对CT图像的窗宽和窗位加以调整，将能够获得更多的诊断信息。当然这种调整是有限度的。 </p><h1 id="分辨力"><a href="#分辨力" class="headerlink" title="分辨力"></a>分辨力</h1><p>图像的分辨力是衡量CT设备图像质量的重要指标，它主要包括空间分辨力、密度分辨力和时间分辨力几方面的内容。 </p><ul><li>空间分辨力（Spatial Resolution） </li></ul><p>图像中可分辨的邻接物体的空间几何尺寸的最小极限，即影像中对细微结构的分辨能力。图像的空间分辨力与单位面积内的像素数目成正比，像素数目越多则空间分辨力越高。 </p><ul><li>密度分辨力（Density Resolution） </li></ul><p>图像中可分辨的密度差别的最小极限，即影像中细微密度差别的分辨能力。图像的密度分辨力也与单位面积内的像素数目有关，在其他条件不变的情况下，矩阵数目越大，每个像素的体积越小，所接受的光量子数则越少，密度分辨力越低。 </p><p>比较CT等数字化成像设备与普通平片可以发现，CT等设备图像的矩阵数目都有限，CT常用512×512的矩阵，而普通平片的每个像素为很小的银盐颗粒，矩阵数目要远远大于数字化成像设备。这样，数字化成像方式，包括CT、MRI、CR等与传统平片相比实际上是提高了密度分辨力，而降低了空间分辨力。 </p><ul><li>时间分辨力（Temporal Resolution） </li></ul><p>指单位时间内设备所能最多采集图像的帧数，与设备的性能参数有关，如采集时间、重建时间、显示方式、连续成像的能力等。在进行腹部实质脏器病变的检查过程中，常需进行增强检查，在增强后进行连续快速的多期相扫描，可以获得更多的信息。因此，设备的时间分辨力，即设备的扫描速度和连续扫描能力对于运动器官和体部脏器的检查是至关重要的。 </p><h1 id="部分容积效应（Partial-Volume-Phenomenon）"><a href="#部分容积效应（Partial-Volume-Phenomenon）" class="headerlink" title="部分容积效应（Partial Volume Phenomenon）"></a>部分容积效应（Partial Volume Phenomenon）</h1><p>在层面成像方式中，如同一层面内含两种以上不同密度的物质，两物质在同一层面内横行走行并互相重叠，即当同一个体素内含有两种以上组织成份时（图1-15），该体素的CT值不能反映任何一种物质，实际上是各种组织CT值的平均。例如当一个体素内同时含有骨骼和肌肉，其CT值可能与肌肉类似，但实际上该体素内并不含有肌肉组织的成分。因此，在高密度区内的小低密度病灶的CT值常偏高，而在低密度区内的小高密度病灶的CT值常偏低。这点<img src="/images/28.png"> </p><h1 id="重建-reconstruction-、回顾性重建-retrospective-reconstruction-和重组-reformation"><a href="#重建-reconstruction-、回顾性重建-retrospective-reconstruction-和重组-reformation" class="headerlink" title="重建(reconstruction)、回顾性重建(retrospective reconstruction)和重组(reformation)"></a>重建(reconstruction)、回顾性重建(retrospective reconstruction)和重组(reformation)</h1><p>重建(reconstruction)是将CT扫描中检测器所采集的原始数据(raw data)经过特殊的数学算法，如反投影法或傅利叶法等计算得到扫描（横断）层面内每个体素的CT值或密度值，形成所需要的数字矩阵与（横断面）CT图像。 </p><p>回顾性重建(retrospective reconstruction)是指为了更好地显示图像的细微结构，对扫描所得的原始数据(raw data)再次有针对性地进行重建，改变和选择最佳的视野大小，视野中心和矩阵数目，根据需要选择特定的算法，如骨、软组织、细节或标准等，多层螺旋CT还可以改变再次重建图像的层厚和层数，从而提高组织间的密度分辨力，使图像更加清晰、细致、柔和，提高对细微结构的敏感性。常用在颞骨内听骨链、肺内结节或细微结构以及垂体病变的显示。 </p><p>重组(reformation)是指对已经重建好的横断面CT图像，通过计算机技术对全部或部分的扫描层面进行进一步后处理，采用不同的方向和不同的显示技术，多角度、多方式立体地显示解剖结构和病变范围，常用的后处理重组方式包括多平面重组、表面遮盖显示、容积再现和仿真内窥镜等。这些不同的显示技术可以弥补CT横断面显示的不足，从不同方向，直观、立体显示解剖结构或病变形态。 </p><h1 id="螺距（Pitch）"><a href="#螺距（Pitch）" class="headerlink" title="螺距（Pitch）"></a>螺距（Pitch）</h1><p>螺旋CT出现以后，由于采用了新的扫描方式的重建算法，在扫描过程中球管每旋转一周床所移动的距离不一定与层厚相同，检查床移动的距离可以等于、小于或大于层厚。为了衡量检查过程中检查床移动的快慢，设定了一个评价指标——螺距，最初它定义为球管旋转一周床所移动的距离与层厚或准值器宽度的比值。在单层螺旋CT设备中，层厚与准值器宽度都是相同的，因此无论采用哪个都是相同的。 </p><p>随着多层螺旋设备的出现，特别是还有4层、16层乃至64层等不同的CT设备，层厚与准值器宽度在上述设备间有很大的不同。为了使螺距的指标在不同类型的设备间能够进行方便的比较，螺距重新定义为： </p><p>螺距=每360º床移动的距离/准值器宽度 </p><p>这样，无论在哪种类型的CT设备，典型的螺距值都位于0~2之间。如果在</p><p>扫描过程中增大螺距，采用螺距大于1的扫描方式，即移床的距离大于准值器宽度，扫描速度将得到提高但图像质量会下降；如减小螺距，采用螺距小于1的扫描方式，即移床的距离小于准值器宽度，扫描速度虽减慢但图像质量会改善。</p><h1 id="团注-Bolus-Injection"><a href="#团注-Bolus-Injection" class="headerlink" title="团注(Bolus Injection)"></a>团注(Bolus Injection)</h1><p>团注是指快速向血管内注入对比剂，单位时间内注射的速度要略高于同时期内该血管的血流量，这样可以使局部血管内的血液全部被注射的对比剂所置换。通过采用团注的注射方式，使动脉中的对比剂浓度在很短的时间内就可以达到峰值，从而可以更好地观察病变的强化行为和特点，避免由于注药时间过长，静脉等所可能造成的干扰。</p><h1 id="伪影（Artifact）"><a href="#伪影（Artifact）" class="headerlink" title="伪影（Artifact）"></a>伪影（Artifact）</h1><p>伪影是指由于扫描时的实际情况与重建图像过程的一系列假设不一致，所带来图像与实际情况不符合的现象。CT中常见的伪影有以下几种：①移动伪影：扫描时由于患者的运动可产生移动性伪影，一般呈条状低密度影；②线束硬化伪影：当X线穿过高密度结构或物质，如枕骨粗隆、牙齿、术后银夹等后，会造成X线穿透特性的改变，从而在以后的计算和重建过程中引起衰减计算的错误，可呈放射状或条带状的高密度或低密度影；③机器故障伪影：这种伪影的原因和类型很多，如检测器工作不正常可造成环形或同心圆状的伪影。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;像素（Pixel）和体素（Voxel）&quot;&gt;&lt;a href=&quot;#像素（Pixel）和体素（Voxel）&quot; class=&quot;headerlink&quot; title=&quot;像素（Pixel）和体素（Voxel）&quot;&gt;&lt;/a&gt;像素（Pixel）和体素（Voxel）&lt;/h1&gt;&lt;p&gt;像素</summary>
      
    
    
    
    <category term="医学科技" scheme="http://example.com/categories/%E5%8C%BB%E5%AD%A6%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="医学" scheme="http://example.com/tags/%E5%8C%BB%E5%AD%A6/"/>
    
    <category term="科技" scheme="http://example.com/tags/%E7%A7%91%E6%8A%80/"/>
    
  </entry>
  
  <entry>
    <title>口腔溃疡</title>
    <link href="http://example.com/2021/03/05/%E5%8F%A3%E8%85%94%E6%BA%83%E7%96%A1/"/>
    <id>http://example.com/2021/03/05/%E5%8F%A3%E8%85%94%E6%BA%83%E7%96%A1/</id>
    <published>2021-03-05T14:57:22.000Z</published>
    <updated>2021-03-05T15:02:26.785Z</updated>
    
    <content type="html"><![CDATA[<p>口腔溃疡又称溃疡性口腔炎，是一种常见的口腔疾病，由病毒或细菌所致。一般常由链球菌、金黄色葡萄球菌、绿脓杆菌及大肠杆菌引起。</p><h1 id="易发部位"><a href="#易发部位" class="headerlink" title="易发部位"></a>易发部位</h1><p>口腔溃疡多见于唇内侧、舌头、舌腹、颊粘膜、前庭沟、软腭等部位，这些地方的粘膜缺乏角质化层或角化较差。而发生与硬腭和附着龈的复发性口腔溃疡则较少见。复发性口腔溃疡的发作规律是部位越往后（咽侧）症状越明显，溃疡越深越大，患者会感觉疼痛剧烈，吃东西难以入口。</p><h1 id="发病原因"><a href="#发病原因" class="headerlink" title="发病原因"></a>发病原因</h1><p>引起口腔溃疡的原因很多，精神过度紧张、情绪波动、睡眠不足，这种情况下很容易出现植物神经功能失调，发病的机会就比较高。在应激状况或身体衰弱的情况下，如你在感冒之初或体力、精神上压力过大时，它就会不定期地出现。这可能与人体内分泌障碍、胃肠功能紊乱、变态反应、局部刺激和微量元素、维生素B1缺乏等有关。</p><h1 id="口腔溃疡病因类型"><a href="#口腔溃疡病因类型" class="headerlink" title="口腔溃疡病因类型"></a>口腔溃疡病因类型</h1><ul><li><p>口腔黏膜病引起的：如疱疹性口炎、手足口病、天疱疮和类天疱疮继发溃疡等，这类溃疡只要及时采用抗菌、抗病毒、抗过敏等治疗措施，或中医药的辨证施治，一般都不会发生恶变。但特别应当注意的是，对属癌前病变的黏膜病不能掉以轻心。如果在白斑、赤斑、扁平苔藓等损害的基础上，出现经久不愈的溃疡，应引起高度警惕。</p></li><li><p>创伤性溃疡：这是一类与局部刺激因素直接有关的溃疡。牙齿折裂留下的残冠、牙齿表面沉积的结石、牙齿长得不齐或者长错位置、咬颊的不良习惯、牙齿磨耗之后形成的尖锐边缘以及做工粗糙的假牙等都可能引起创伤性溃疡。对于这种溃疡，只要尽早发现致病因素，及时采取诸如拔除残根残冠、磨改尖锐边缘、洁治牙结石、纠正咬颊习惯、重新镶牙等措施，就会很快愈合的。但是，如果发现过迟，措施不力，创伤性口腔溃疡就可能癌变。</p></li><li><p>由肿瘤引起的”恶性溃疡”：这种溃疡是恶性肿瘤局部浸润性发展的结果，在溃疡出现前就可能已出现恶性肿瘤的全身表现。</p></li></ul><h1 id="复发性口腔溃疡"><a href="#复发性口腔溃疡" class="headerlink" title="复发性口腔溃疡"></a>复发性口腔溃疡</h1><p>口腔溃疡反反复复的发作，医学上称其为”复发性口腔溃疡”。复发性口腔溃疡一年四季均可发生，可出现于口腔黏膜的任何部位，唇颊舌较多见，多发生于青壮年，女性多于男性。其复发时间长短与口腔溃疡病史长短有密切关系，病史短时，可以几个月或一年发病一次；病史长时，可以一个月发病一次，或口腔溃疡新旧病变交替出现。一般情况下10天左右可自愈，不留疤痕。复发性口腔溃疡，是口腔粘膜病中最常见的疾病，反复发作但又有自限性，局部表现为孤立的、圆形或者椭圆形溃疡。临床上分为三种类型：复发性轻型口腔溃疡、复发性口炎性口腔溃疡、复发性坏死性粘膜腺周围炎。</p><p>复发性口腔溃疡首先与免疫有着很密切的关系。有的患者表现为免疫缺陷，有的患者则表现为自身免疫反应，也就是由于各种因素，使人体正常的免疫系统，对自身组织抗原，产生免疫反应，引起组织的破坏而发病。</p><p>其次与遗传有关系，在临床中，复发性口腔溃疡的发病，有明显的家族遗传倾向，我们常常看到，父母一方或双方若患有复发性口腔溃疡，那么，他们的子女就比一般人更容易患病。另外，复发性口腔溃疡的发作，常常还与一些疾病或症状有关，比如消化系统疾病：胃溃疡、十二指肠溃疡、慢性或迁延性肝炎、结肠炎等，另外贫血、偏食、消化不良、腹泻、发热、睡眠不足、过度疲劳、精神紧张、工作压力大、月经周期的改变等等。</p><p>随着一种或多种因素的活跃、交替、重叠就容易出现机体免疫力下降，免疫功能紊乱，也就造成了复发性口腔溃疡的频繁发作。</p><p>复发性口腔溃疡的典型表现是初起时有很细的小斑点，伴有灼热不适感，然后逐渐扩大为直径2～3毫米或更大的浅溃疡。溃疡微微有些凹陷，表面有一层淡黄色的假膜覆盖，溃疡周围的粘膜由于充血而呈红晕状，灼痛明显。</p><p>当接触有刺激的食物时疼痛更加剧烈。复发性口腔溃疡的发作有自限性和周期性，一般的复发性口腔溃疡如果不经特殊治疗7～10天可逐渐愈合，间歇期长短不等，几天到数月，此起彼伏，反复发作。</p><h1 id="口腔溃疡的家庭护理"><a href="#口腔溃疡的家庭护理" class="headerlink" title="口腔溃疡的家庭护理"></a>口腔溃疡的家庭护理</h1><p>没人知道为何有些人会得口腔溃疡，有些人不会。口腔溃疡常发生在口部，但也可出现在舌头、脸颊内侧、嘴唇或牙龈。口腔习惯不良、遗传、食物、刷牙过猛及情绪紧张等，均与口腔溃疡有密切关系。不论是什么因素造成，治疗口腔溃疡是件麻烦的事。口腔是全身细菌窝藏最多之处，治疗口腔溃疡有双重目的：一方面要消灭那些感染口腔溃疡的细菌，一方面要保护伤口。通过一些家庭治疗措施可以很有效地治疗口腔溃疡。</p><ul><li>双氧水</li></ul><p>可以用碳硫二胺双氧水，它含双氧水和甘油。双氧水可以将氧释出并将细菌清除，氧气泡进入微小的隙缝，甘油则覆盖溃疡并对它加以保护。</p><ul><li>用氯酸钾漱口</li></ul><p>可以加1茶匙氯酸钾于l杯水中，用此溶液漱口，一天数次，可治疗口腔溃疡。但不要吞入。</p><ul><li>试用红茶包</li></ul><p>有些专家建议在溃疡部位敷湿的红茶包。红茶含鞣酸，此物有收敛作用，止痛效果也不错。</p><ul><li>用稀释的双氧水漱口</li></ul><p>用1杯水稀释1汤匙双氧水，以此溶液漱口，可防止口腔溃疡感染，并加速复原。</p><ul><li>用明矾可以防止感染恶化</li></ul><p>明矾是止血药里的活性成分，可在口腔溃疡初期使用。明矾是一种杀菌剂及止痛剂，它能防止感染恶化，但它无法消除口腔溃疡。</p><ul><li>用氧化镁漱口</li></ul><p>氧化镁可在口腔溃疡表面形成保护层，也具有抗菌效果。</p><ul><li>用金印草制漱口水</li></ul><p>用金印草根制成浓茶，当作漱口水。或制成糊状物，直接涂在溃疡上，效果不错。</p><ul><li>避免刺激性物质</li></ul><p>咖啡、辛辣调味料、柳橙类水果、富含精氨酸的核果 尤其是胡桃 、巧克力及草莓等物，会刺激口腔溃疡，并使某些人产生口腔溃疡。因此应避免这类食物。</p><ul><li>每天吃酸酪乳</li></ul><p>每天吃4汤匙的原味酸酪乳，可将良性菌送入口腔，与那些有害的细菌作战，有益于预防口腔溃疡。</p><ul><li>避免会引起溃疡的食物</li></ul><p>避免口香糖、抽烟、咖啡、烫的食物及那些会诱发口腔溃疡的食物。</p><ul><li><p>营养素</p></li><li><p>离氨酸 氰基酸</p></li></ul><p>每日3次，各500毫克，空腹服用。缺乏此氨基酸可能在口腔内外爆发口腔溃疡。</p><ul><li>添加维生素B12及叶酸</li></ul><p>用量依产品说明，含于舌下，空腹服用。</p><ul><li>维生素C</li></ul><p>每日3000 8000毫克，分成数次。用含生物类黄酮且缓冲过的剂型。</p><ul><li>泛酸 D5</li></ul><p>每日3次，各50 100毫克是抗紧张的维生素，对肾上腺功能是必需的。肾上腺是对抗紧张的内分泌腺。</p><ul><li>蒜头精胶囊</li></ul><p>每日3次，各3粒。当作一种天然抗生素及免疫激活剂。</p><ul><li>药用植物</li></ul><p>治疗口腔溃疡可使用牛蒡、金印草、保哥果茶及红苜蓿。红覆盆子茶也非常有效。</p><ul><li>多吃洋葱和生菜</li></ul><p>吃大量的洋葱生菜沙拉。洋葱含硫成分，有治疗功效。</p><h1 id="预防措施"><a href="#预防措施" class="headerlink" title="预防措施"></a>预防措施</h1><p>对口腔溃疡的治疗方法虽然很多，但基本上都是对症治疗，目的主要是减轻疼痛或减少复发次数，很难完全控制复发，口腔溃疡在很大程度上与个人身体素质有关，因此，要想完全避免其发生，可能性不大，但如果尽量避免诱发因素，仍可降低发生率。所以对本病预防尤为重要。在生活中应注意以下几个方面：</p><p>注意口腔卫生，避免损伤口腔黏膜。<br>保证充足的睡眠时间，避免过度疲劳。<br>保持心情舒畅，乐观开朗，避免着急。<br>注意生活起居规律性和营养均衡性，戒除烟酒，坚持体育锻炼，饮食清淡，多吃蔬菜水果，保持大便通畅，防止便秘。妇女经期前后要注意休息，保持心情愉快，避免过度疲劳，饮食要清淡，多吃水果，新鲜蔬菜，多饮水等等，以减少口疮发生的机会。<br>五、特别提醒<br>白塞氏病、口腔粘膜损伤性溃疡、疱疹性口炎、多形性红斑、结核性溃疡、接触性口炎、坏死性龈口炎和癌肿溃疡等疾病临床上也都可表现为口腔溃疡，其中以癌肿溃疡最为危险。在口腔溃疡的恶性肿瘤中，鳞状细胞癌约占90%。</p><p>鳞癌可分为舌癌、龈癌、颊癌、口底癌等。在其他癌性肿瘤中，腺癌、恶性黑色素瘤、恶性淋巴瘤、位于腭部的恶性混合瘤也可表现为口腔粘膜的癌肿溃疡。到目前为止，导致口腔癌的原因尚不完全清楚，已知的发病因素有：慢性刺激（锐利的牙尖、不良修复体等对颊、舌粘膜的经常性刺激）；慢性炎性口腔溃疡（如舌的慢性溃疡，软腭的慢性口腔溃疡等长期不愈，易导致癌变）。</p><p>这些均可表现为癌肿溃疡，常见于唇、舌部、表现为边缘不规则的深溃疡，边缘坚韧、凸出，周围有浸润。无论其中哪一种表现为口腔溃疡的疾病，都不容忽视，必须早期发现早期治疗为好。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;口腔溃疡又称溃疡性口腔炎，是一种常见的口腔疾病，由病毒或细菌所致。一般常由链球菌、金黄色葡萄球菌、绿脓杆菌及大肠杆菌引起。&lt;/p&gt;
&lt;h1 id=&quot;易发部位&quot;&gt;&lt;a href=&quot;#易发部位&quot; class=&quot;headerlink&quot; title=&quot;易发部位&quot;&gt;&lt;/a&gt;易发部位&lt;</summary>
      
    
    
    
    <category term="医疗健康" scheme="http://example.com/categories/%E5%8C%BB%E7%96%97%E5%81%A5%E5%BA%B7/"/>
    
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="生活" scheme="http://example.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
    <category term="口腔健康" scheme="http://example.com/tags/%E5%8F%A3%E8%85%94%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>信号之路</title>
    <link href="http://example.com/2021/03/05/%E4%BF%A1%E5%8F%B7%E4%B9%8B%E8%B7%AF/"/>
    <id>http://example.com/2021/03/05/%E4%BF%A1%E5%8F%B7%E4%B9%8B%E8%B7%AF/</id>
    <published>2021-03-05T13:16:22.000Z</published>
    <updated>2021-03-05T14:38:59.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="The-long-timeline-to-the-5G-revolution-is-about-to-reach-its-end"><a href="#The-long-timeline-to-the-5G-revolution-is-about-to-reach-its-end" class="headerlink" title="The long-timeline to the 5G revolution is about to reach its end"></a>The long-timeline to the 5G revolution is about to reach its end</h1><h2 id="5G革命的漫长时光即将结束"><a href="#5G革命的漫长时光即将结束" class="headerlink" title="5G革命的漫长时光即将结束"></a>5G革命的漫长时光即将结束</h2><p>As phone makers and cellular plan providers start to advertise their 5G capabilities it is reasonable to think that the 5G revolution is here. Everyone’s talking about 5G. We’ve heard that “5G is coming” for so long, it seems hard to look up from our slow cell phones and ask “is this it, is it here”. What does 5G mean, and where is it?<br>随着电话制造商和蜂窝计划提供商开始宣传其5G功能，可以合理地认为5G革命已经来临。 大家都在谈论5G。 我们已经听到“ 5G即将到来”这么长时间了，似乎很难从我们速度较慢的手机上抬起头来，问“这就是它吗，它在这里”。 5G是什么意思，它在哪里？</p><p>Simply put, 5G is the fifth generation of cellular wireless and mobile technology. 5G promises to deliver speeds in excess of 1 Gigabits per second approximately 10 times faster than current 4G capabilities with and ultra-low latency. Realistically this should make possible a massive transition to device connection with the “internet of things”.<br>简而言之，5G是蜂窝无线和移动技术的第五代。 5G承诺以超过1Gbps的速度提供每秒超过1 Gigabit的速度，这是目前4G功能的超快速度，并且具有超低延迟。 实际上，这应该使大规模过渡到与“物联网”的设备连接成为可能。</p><p>5G aims to address the ever-increasing demand for more bandwidth, speed, and data traffic. It’s estimated that by 2024, 25 percent of mobile data traffic will be carried by 5G networks. That’s approximately 30 percent more traffic than is carried by 4G/3G/2G networks today. While this is impressive, it is also estimated that there will be more than 60 times growth in mobile data traffic from 2013–2024.<br>5G旨在满足对更大带宽，速度和数据流量的不断增长的需求。 据估计，到2024年，5G网络将承载25％的移动数据流量。 这比今天的4G / 3G / 2G网络传输的流量大约多30％。 尽管这令人印象深刻，但据估计，从2013年至2024年，移动数据流量的增长将超过60倍。</p><h2 id="我们是怎么来到这里的？-How-did-we-get-here"><a href="#我们是怎么来到这里的？-How-did-we-get-here" class="headerlink" title="我们是怎么来到这里的？ (How did we get here?)"></a>我们是怎么来到这里的？ (How did we get here?)</h2><p>It seems worthwhile to talk about the development of the cellular technology to better understand 5G and have greater appreciation for the future.<br>谈论蜂窝技术的发展似乎是值得的，以便更好地了解5G并对未来有更大的赞赏。<br><img src="/images/23.png"><br>1G sounds ridiculous, but then again I wasn’t alive in 1983 when it was delivered. The radio signals used by 1G networks are analog. This gave a whopping 2.4 kilobits per second.<br>1G听起来很荒谬，但是在1983年交付时，我还活着。 1G网络使用的无线电信号是模拟的。 这样就产生了高达每秒2.4 kb的速度。</p><p>2G which largely replaced 1G came about in 1991 allowing for 01. megabits per second. This gave rise to sms text capabilities.<br>1991年出现的2G基本上取代了1G，允许每秒01. Mbps的速度。 这引起了短信文本功能。</p><p>3G was perhaps the first speed many younger people remember from the slow Facebook browsing they could perform on their flip or slide-out keyboard phone. The earliest days of 3G were in 1998. 3G capabilities range from 1–8 megabits per second.<br>3G可能是许多年轻人从Facebook缓慢的浏览中记住的第一速，他们可以在翻盖或滑出式键盘电话上执行该操作。 3G最早出现在1998年。3G的能力范围为每秒1至8兆比特。</p><p>4G technology was a large step up from what came before, and needs no real introduction since most of us still live with its capabilities (and confines) today. 4G allows for about 15–100 megabits per second. The world began giving way to 4G in 2008, with the fast internet browsing, video streaming and video conferencing capabilities.<br>4G技术比以前有了很大的进步，并且不需要真正的介绍，因为我们大多数人仍然生活在今天的能力(和局限)内。 4G允许每秒约15–100兆位。 快速的Internet浏览，视频流和视频会议功能于2008年开始被4G取代。</p><p>You might have noticed that each of these sites a year earlier than when you might have had access to the technology. That is a reminder that reality of these technologies take some time from their conception, proof of concept, into implementation. 5G technology is here, it is being proven, but we are a long way from ubiquity.<br>您可能已经注意到，每个站点都比您可以使用该技术的时间早一年。 这提醒人们，这些技术的现实需要一段时间才能从其概念(概念验证)到实现。 5G技术已经来临，它已经被证明，但是距离普遍性还有很长的路要走。</p><p>5G may promise speeds of .1–1 gigabits per second, thus revolutionizing our society such as self driving cars communicating to each other on the road or ultra responsive remote robotic surgeries without latency. The reality is obviously more humbled, and will be for quite some time. In many parts of the United States you will struggle to get quality 3G capabilities. Again, a technology developed in the late 90s.<br>5G可以保证每秒1-1吉比特的速度，从而彻底改变了我们的社会，例如无人驾驶汽车在道路上相互通信或无延迟的超灵敏远程机器人手术。 现实显然更加卑微，并将持续相当长的一段时间。 在美国许多地方，您将很难获得优质的3G功能。 同样，这项技术是在90年代后期开发的。</p><p>This isn’t to throw cold water on the 5G optimists and all that it promises. We should remember that the 5G revolution won’t be instantaneous like many of the flashy new cell phone or cell network commercials would have you believe. Instead, the transition takes time to reach a critical mass and it will happen in cities and other areas far earlier than it takes hold “everywhere”.<br>这并不是要对5G乐观主义者及其所承诺的一切泼冷水。 我们应该记住，5G革命不会像许多浮华的新手机或蜂窝网络商业广告那样让您相信。 取而代之的是，过渡过程需要时间才能达到临界点，并且将在城市和其他地区发生，要比在“任何地方”都早。</p><p>5G is here, now, but it is not widespread. It’s been in the works for nearly a decade, but it took about 25 years to go from first generation analog cellular (1G) to move into 4G.<br>5G现在就在这里，但尚未普及。 它已经投入使用了近十年，但从第一代模拟蜂窝(1G)进入4G大约需要25年的时间。<br><img src="/images/24.png"><br>Steps are being taken to get 5G off the ground in the United States. The first release of 5G, in late 2017 by the 3rd generation partnership project (3GPP) was for non-stand-alone New Radio (NR). In June 2018, 3GPP finalized its release for stand-alon 5G.<br>美国正在采取措施使5G面世。 第三代合作伙伴计划 (3GPP)于2017年末发布了5G的第一版，该版本用于非独立的新无线电(NR)。 3GPP于2018年6月完成了其标准5G版本的发布。</p><p>Additionally, the International Telecommunication Union (ITU), an agency of the United Nations tasked with establishing standards associated with communications and technology on an international level, is working on a set of 5G standards known as International Mobile Technologies-2020<br>此外，联合国机构国际电信联盟(ITU)的任务是建立与国际水平上的通信和技术相关的标准，该组织正在制定一套称为国际移动技术2020的5G标准。</p><p>Currently, all the major carriers are rolling out fixed and mobile 5G services, but exclusively in a handful of cities. As of November 2019, there were 46 5G networks launched in the US. Every year that number will increase exponentially, but in 2020 in the United States we can only expect more 5G networks in densely populated urban areas.<br>当前，所有主要运营商都在少数几个城市推出固定和移动5G服务。 截至2019年11月， 在美国推出了46个5G网络 。 每年，这个数字都会成倍增加，但是到2020年，在美国，我们只能期望在人口稠密的城市地区拥有更多的5G网络。</p><p>So you might be wondering: “When will 5G really arrive for me?”<br>因此，您可能会想：“ 5G何时真正为我到达？”</p><h2 id="别担心，现在不会很快。-Don’t-worry-it-won’t-be-long-now"><a href="#别担心，现在不会很快。-Don’t-worry-it-won’t-be-long-now" class="headerlink" title="别担心，现在不会很快。 (Don’t worry it won’t be long now.)"></a>别担心，现在不会很快。 (Don’t worry it won’t be long now.)</h2><p>Obviously, there are a few answers to how long you will have to wait depending on where you live, what carriers you have (or would have access to), your ability to buy a 5G devices, and a myriad of other concerns. The short answer is: By 2022 you’ll start to see more advanced 5G infrastructure outside of just major cities and the 5G phones will become more cost effective and hit mainstream use.<br>显然，根据您的居住地，拥有(或可以使用)的运营商，购买5G设备的能力以及众多其他问题，您需要等待多长时间会有一些答案。 简短的答案是：到2022年，您将开始在主要城市之外看到更先进的5G基础设施，而5G手机将变得更具成本效益，并成为主流用途。</p><p>5G subscribers are expected to reach 1.1 billion by 2023 across the Asia-Pacific and North America regions, where the next-generation network has been launched. That would be triple the number of subscribers 4G reached in the same five-year time period after launching.<br>到2023年 ，亚太地区和北美地区(已启动下一代网络)的5G用户预计将达到11亿 。 在启动后的同一五年时间内，这将是4G用户数量的三倍。</p><p>5G infrastructure will be the main hurdle. There are a number of reasons why the 5G infrastructure is taking so long.<br>5G基础设施将是主要障碍。 5G基础设施耗时如此长的原因有很多。</p><p>First, is the high-cost to physically implement the 5G millimeter wave network. There are three-frequency bands that 5G networks can operate on: sub-3 GHz (the low band), 3GHz to 7 GHz (the mid-band), and the faster 24 GHz and above millimeter waves. The lower bands overlap with 4G and that infrastructure could be utilized, but the higher frequencies will require more and newer infrastructure.<br>首先，物理上实现5G毫米波网络是高成本。 5G网络可以在三个频段上运行：低于3 GHz(低频段)，3 GHz至7 GHz(中频段)以及更快的24 GHz及以上毫米波。 较低的频段与4G重叠，可以利用该基础架构，但是较高的频率将需要更多和更新的基础架构。</p><p>Second, is the acquisition of local regulatory approvals for construction of the antennas, and the general lack of regulatory clarity around 5G. Because of the shorter wavelengths, 5G requires far more wireless antenna connections than 4G, which is one of the primary reason it is now only available in densely populated areas.<br>其次，是获得了当地有关天线构造的监管批准，以及围绕5G普遍缺乏监管的明确性。 由于波长较短，因此5G需要比4G多得多的无线天线连接，这是它现在只能在人口稠密地区使用的主要原因之一。</p><p>Telecom companies no what it takes to overcome these obstacles. Over the next 10–15 years 5G will also drive new global infrastructure projects. It is estimated that telecom companies will invest as much as $275 billion into 5G infrastructure before 2025.<br>电信公司无须克服这些障碍。 在接下来的10-15年中，5G也将推动新的全球基础设施项目。 据估计，到2025年之前，电信公司将在5G基础设施上投资高达2,750亿美元。</p><p>The last, is the availability of devices. 2020 and all those commercials for 5G are probably premature, but this year we are already seeing a meaningful impact on the consumer. Whether they will see the full impact of the technology or not, consumers are demanding the theoretical capabilities. According to Deloitte’s first US connectivity and Mobile Trends survey, 67 percent of consumers said that they would be more likely to buy a new smartphone if it had 5G-compatibility.<br>最后，是设备的可用性。 2020年以及所有用于5G的商业广告可能还为时过早，但今年我们已经看到了对消费者的有意义的影响。 不管他们是否看到技术的全部影响，消费者都要求理论上的能力。 根据德勤(Deloitte)首次在美国进行的连接性和移动趋势调查 ，有67％的消费者表示，如果具有5G兼容性，他们将更有可能购买新的智能手机。</p><p>IHS markit predicts that 5G’s full economic impact should be realized by 2035 and could produce up to $13.2 trillion attributable worth of goods and services as enabled by 5G mobile technology and support up to 22.3 million jobs!<br>IHS Markit预测 5G的全部经济影响应在2035年之前实现，并可能通过5G移动技术实现高达13.2万亿美元的商品和服务价值，并支持多达2230万个工作岗位！</p><p>This is a reminder that the short term promise of 5G ubiquity is an illusion, but the long-term opportunity and gains will be there. When I was (even) younger, I couldn’t imagine what my cell phone can do now. I was happy with my slow loading internet and SMS/call only communication. Now about 10 years later, I throw a fit when my 4G drops to 3G or lower. Technology can and does proceed quickly, but never overnight.<br>这提醒我们，5G普遍存在的短期前景是一种幻想，但长期机会和收益将在那里。 当我(甚至)年轻的时候，我无法想象我的手机现在能做什么。 我对缓慢的Internet连接和SMS /仅呼叫通信感到满意。 现在大约10年后，当我的4G降至3G或更低时，我感到很满意。 技术可以而且确实会Swift进行，但绝不会一overnight而就</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;The-long-timeline-to-the-5G-revolution-is-about-to-reach-its-end&quot;&gt;&lt;a href=&quot;#The-long-timeline-to-the-5G-revolution-is-about-to-reach</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>5G简介</title>
    <link href="http://example.com/2021/03/05/5G%E7%AE%80%E4%BB%8B/"/>
    <id>http://example.com/2021/03/05/5G%E7%AE%80%E4%BB%8B/</id>
    <published>2021-03-05T12:48:26.000Z</published>
    <updated>2021-03-05T14:41:00.497Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5G"><a href="#5G" class="headerlink" title="5G"></a>5G</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>5G网络是第五代移动通信网络，其峰值理论传输速度可达每秒数10Gb，比4G网络的传输速度快数百倍。举例来说，一部1G的电影可在8秒之内下载完成。</p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>电磁波<br>日常生活中，除了原子电子之外，剩下的几乎全是电磁波，红外线、紫外线、太阳光、电灯光、wifi信号、手机信号、电脑辐射、核辐射，等等。只要是波，就逃不过三个参数：波速、波长、振幅。电磁波的速度是恒定的光速，因此只需考虑：波长(或频率)、振幅(不考虑方向)，其中频率对于电磁波来说，尤为重要。</p><p>频率越高，对应着电磁波的波长越短，能量越高，衰减越快，穿透性越差，散射越少，对人体伤害越大。<br>长的电磁波波长能到1亿米，频率3Hz，1秒钟三个波，如果用来通信的话，等你一句话说完，就可以过年了。<br>稍微正常点的电磁波，波长几万米，用这通信，就一个字：稳！江河大山都挡不住，甚至能穿透几十米深的海水(海水导电，是电磁波的克星)。不过就这点频率，只能勉强携带点信息，发一个hello，大概需要半小时，也就比写信稍微强点。因为超长波实在是稳，一般用在岸台向潜艇单向发送命令。<br>再短点，几十米波长的电磁波，频率就到了百万赫兹MHz级别，能携带的信息就很可观了，一句话至少能说利索了。而且照样还能跑很远，几百公里不在话下，所以收音机广播、电报、业余无线电一般用这个频段。<br>说点有用的，假如你困在荒岛上，有个飞机路过，赶紧用121.5MHz呼救，这是民用紧急通信频率，还有个军用紧急通信频率243MHz，这些都是不加密的公共频率。上次解放军和台军战机对峙，双方用这个频率对话，结果被无线电爱好者录下来放网上了，吃瓜群众喜闻乐见之余，又担心我军通信太容易被破解，真是阿弥陀佛了。<br>波长再短点，到了1米~1厘米，就有意思了。一方面，虽然衰减已经很明显了，但一口气还能跑个百十公里，够用；另一方面，频率到了GHz级别，能携带足够多的信息，不但话能说利索了，还有多余功夫让你加个密什么的。所以这个波段是通信的焦点，什么1G2G3G4G，什么卫星通信雷达通信，全在这，统称微波通信。<br>到了毫米级，电磁波就跑不了多远了，虽然毫米波不太发散，但很容易被周边物质吸收或反射，几乎没啥穿透性，用来通信很鸡肋，不过用在导弹导引雷达或微波炉上棒棒的。但，毕竟频率超过了30GHz，携带的信息量实在太馋人，要不还是试试吧！于是，5G来了。<br>5G同志先等等，继续往下数，来到微米级。毫无疑问，能携带的信息量继续倍增，但波长0.7微米的电磁波就已经是可见光了。可见光都见过吧，别说穿墙了，一张纸都够呛，想接着按照7G8G9G的套路肯定走不通啊。然后，就有了激光通信，发射端和接收端必须瞄得准准的，中间还不能有阻挡，这优缺点自个儿体会体会。<br>波长到了0.3微米，也就是300纳米，先别管频率的事了，这玩意儿就是我们熟知的紫外线，终于对人体有害了。太阳光里的紫外线大约占了4%，如果你一天能晒上半小时太阳的话，那么前面提到的那些电磁波辐射基本可以无视了(不要钻电磁共振的牛角尖，咱只说普遍情况)。<br>波长200纳米的紫外线，在太阳光中几乎是没有的，所以在阳光太强时，紫外线通信就成了激光通信很好的补充，不但隐蔽性更好，还不用对得那么准，在几公里的距离上非常好用，是近些年军事通信的研究热点。<br>接下来就和通信无关了，波长到了纳米级就成了X光，就是在医院见到的那种，这么说的话，X光其实也能叫纳米技术(这是玩笑)。<br>最后，波长短到了0.01纳米以下，这就是闻之色变的伽马射线，来自核辐射，全宇宙最强的能量形式之一！若是要毁灭一个星系，伽马射线是不二之选。实际上，科学家一直怀疑，超新星爆炸产生的伽马射线爆已经毁灭了绝大部分的宇宙文明，好在太阳系处于比较角落的地带，周边恒星不多。<br>不偏题，回到电波先。电波属于电磁波的一种，它的频率资源是有限的。为了避免干扰和冲突，我们在电波这条公路上进一步划分车道 ，分配给不同的对象和用途。<br><img src="/images/9.png"><br>请大家注意上面图中的红色字体。一直以来，我们主要是用中频 ~ 超高频进行手机通信的。例如经常说的「GSM900」、「CDMA800」，其实意思就是指，工作频段在 900MHz 的 GSM，和工作频段在 800MHz 的 CDMA。<br>目前全球主流的 4G LTE 技术标准，属于特高频和超高频。我们国家主要使用超高频：<br><img src="/images/10.png"></p><ul><li>通信中的1和0及高频与高速<br>为什么频率越高，能携带的信息就越多？以数字信号为例，信息就是一串串的1和0，所以先搞清楚怎样用电磁波表示1和0。<br>　　第一种方法叫“调幅”，基本思路是调整电磁波的振幅，振幅大的表示1，振幅小的表示0，如下图。收音机的AM就是调幅，缺点颇多。<br><img src="/images/11.png"><br>第二种方法叫“调频”，基本思路是调整频率来表示1和0，比如，用密集的波形表示1，疏松的波形表示0。收音机的FM就是调频，优点多多的。<br><img src="/images/12.png"><br>很显然，在单位时间内，发出的波越多，能表示的1和0就越多，换句话说，频率越高能携带的信息就越多。<br>这样算起来，频率800MHz意味着每秒产生800万个波，都用来表示1和0的话，1秒钟可以传输100M数据，这速度很快啊！为啥我们感觉不到呢？<br>古语有云，重要的事情说三遍，通信也是如此。无线电拔山涉水，弄丢几个1,0太正常了，防止走丢的土办法就是抱团。比如，用一万个连续的1表示一个1，哪怕路上走丢了两千个1，最后咱还能认得这是1。<br>这种傻办法只能用在民用通信，因为特征太明显，很容易被破解。还记得北斗民用信号被破解的新闻吧，原因就在此。<br>民用信号只要能和其他信号区分开就行，不会弄得太复杂，不然传输效率太低。按2G技术那样，800MHz的频率，传输数据大不过每秒几十K。<br>军用就两码事了，为了防止被破解，要用很复杂的组合来表示1和0，中间说不定还有很多无效信息，各种跳频技术扩频技术，还不停变换组合，总之越花哨越好。所以同样一句话，军事通信要用掉更多的1,0，因此为了保证传输效率，军用频率就比民用高很多。<br>就目前来说，顶级破解技术还干不过顶级加密技术，这里不包括尚未成熟的量子通信。<br>军事对抗是无止境的，干不过也不能认怂！那怎办？既然弄不清楚你的1,0，那我就索性再送你一堆1,0，把你原有的组合搞乱，让你自己人都懵逼。这就是电子对抗的环节，跑题了，还是说回5G。<h2 id="5G的频段"><a href="#5G的频段" class="headerlink" title="5G的频段"></a>5G的频段</h2></li><li>更高 的频率→ 更多 的资源→ 更快 的速度<br>5G 使用的频率具体如下图所示：<br><img src="/images/13.png"><br>5G 的频率范围，分为两种：一种是 6GHz 以下，这个和目前我们的 2/3/4G 差别不算太大。还有一种，就很高了，在 24GHz 以上。目前，国际上主要使用 28GHz 进行试验（这个频段也有可能成为 5G 最先商用的频段）。<br>如果按 28GHz 来算，根据前文我们提到的公式，波长位10.7mm——毫 米 波。<br>移动通信如果用了高频段，那么它最大的问题，就是传输距离大幅缩短， 覆盖能力大幅减弱 。覆盖同一个区域，需要的 5G 基站数量，将大大超过 4G。<br><img src="/images/14.png"><h2 id="5G的六大基本特点"><a href="#5G的六大基本特点" class="headerlink" title="5G的六大基本特点"></a>5G的六大基本特点</h2></li><li>高速度<br>相对于4G，5G要解决的第一个问题就是高速度。网络速度提升，用户体验与感受才会有较大提高，网络才能面对VR/超高清业务时不受限制，对网络速度要求很高的业务才能被广泛推广和使用。因此，5G第一个特点就定义了速度的提升。<br>其实和每一代通信技术一样，确切说5G的速度到底是多少是很难的，一方面峰值速度和用户的实际体验速度不一样，不同的技术不同的时期速率也会不同。对于5G的基站峰值要求不低于20Gb/s，当然这个速度是峰值速度，不是每一个用户的体验。随着新技术使用，这个速度还有提升的空间。<br>这样一个速度，意味着用户可以每秒钟下载一部高清电影，也可能支持VR视频。这样的高速度给未来对速度有很高要求的业务提供了机会和可能。</li><li>泛在网<br>随着业务的发展，网络业务需要无所不包，广泛存在。只有这样才能支持更加丰富的业务，才能在复杂的场景上使用。泛在网有两个层面的含义。一是广泛覆盖，一是纵深覆盖。<br>广泛是指我们社会生活的各个地方，需要广覆盖，以前高山峡谷就不一定需要网络覆盖，因为生活的人很少，但是如果能覆盖5G，可以大量部署传感器，进行环境、空气质量甚至地貌变化、地震的监测，这就非常有价值。5G可以为更多这类应用提供网络。<br>纵深是指我们生活中，虽然已经有网络部署，但是需要进入更高品质的深度覆盖。我们今天家中已经有了4G网络，但是家中的卫生间可能网络质量不是太好，地下停车库基本没信号，现在是可以接受的状态。5G的到来，可把以前网络品质不好的卫生间、地下停车库等都用很好的5G网络广泛覆盖。<br>一定程度上，泛在网比高速度还重要，只是建一个少数地方覆盖、速度很高的网络，并不能保证5G的服务与体验，而泛在网才是5G体验的一个根本保证。在3GPP的三大场景没有讲泛在网，但是泛在的要求是隐含在所有场景中的。</li><li>低功耗<br>5G要支持大规模物联网应用，就必须要有功耗的要求。这些年，可穿戴产品有一定发展，但是遇到很多瓶颈，最大的瓶颈是体验较差。以智能手表为例，每天充电，甚至不到一天就需要充电。所有物联网产品都需要通信与能源，虽然今天通信可以通过多种手段实现，但是能源的供应只能靠电池。通信过程若消耗大量的能量，就很难让物联网产品被用户广泛接受。<br>如果能把功耗降下来，让大部分物联网产品一周充一次电，甚或一个月充一次电，就能大大改善用户体验，促进物联网产品的快速普及。eMTC基于LTE协议演进而来，为了更加适合物与物之间的通信，也为了更低的成本，对LTE协议进行了裁剪和优化。eMTC基于蜂窝网络进行部署，其用户设备通过支持1.4MHz的射频和基带带宽，可以直接接入现有的LTE网络。eMTC支持上下行最大1Mbps的峰值速率。而NB-IoT构建于蜂窝网络，只消耗大约180kHz的带宽，可直接部署于GSM网络、UMTS网络或LTE网络，以降低部署成本、实现平滑升级。<br>NB-IoT其实基于GSM网络和UMTS网络就可以进行部署，它不需要和5G的核心技术那样需重新建设网络，但是，虽然它部署在GSM和UMTS的网络上，还是一个重新建设的网络，而它的能力是大大降低功耗，也是为了满足5G对于低功耗物联网应用场景的需要，和eMTC一样，是5G网络体系的一个组成部分。</li><li>低时延<br>5G的一个新场景是无人驾驶、工业自动化的高可靠连接。人与人之间进行信息交流，140毫秒的时延是可以接受的，但是如果这个时延用于无人驾驶、工业自动化就无法接受。5G对于时延的最低要求是1毫秒，甚至更低。这就对网络提出严酷的要求。而5G是这些新领域应用的必然要求。<br>无人驾驶汽车，需要中央控制中心和汽车进行互联，车与车之间也应进行互联，在高速度行动中，一个制动，需要瞬间把信息送到车上做出反应，100毫秒左右的时间，车就会冲出几十米，这就需要在最短的时延中，把信息送到车上，进行制动与车控反应。<br>无人驾驶飞机更是如此。如数百架无人驾驶编队飞行，极小的偏差就会导致碰撞和事故，这就需要在极小的时延中，把信息传递给飞行中的无人驾驶飞机。工业自动化过程中，一个机械臂的操作，如果要做到极精细化，保证工作的高品质与精准性，也是需要极小的时延，最及时地做出反应。这些特征，在传统的人与人通信，甚至人与机器通信时，要求都不那么高，因为人的反应是较慢的，也不需要机器那么高的效率与精细化。而无论是无人驾驶飞机、无人驾驶汽车还是工业自动化，都是高速度运行，还需要在高速中保证及时信息传递和及时反应，这就对时延提出了极高要求。<br>要满足低时延的要求，需要在5G网络建构中找到各种办法，减少时延。边缘计算这样的技术也会被采用到5G的网络架构中。</li><li>万物互联<br>传统通信中，终端是非常有限的，固定电话时代，电话是以人群为定义的。而手机时代，终端数量有了巨大爆发，手机是按个人应用来定义的。到了5G时代，终端不是按人来定义，因为每人可能拥有数个，每个家庭可能拥有数个终端。<br>2018年，中国移动终端用户已经达到14亿，这其中以手机为主。而通信业对5G的愿景是每一平方公里，可以支撑100万个移动终端。未来接入到网络中的终端，不仅是我们今天的手机，还会有更多千奇百怪的产品。可以说，我们生活中每一个产品都有可能通过5G接入网络。我们的眼镜、手机、衣服、腰带、鞋子都有可能接入网络，成为智能产品。家中的门窗、门锁、空气净化器、新风机、加湿器、空调、冰箱、洗衣机都可能进入智能时代，也通过5G接入网络，我们的家庭成为智慧家庭。<br>而社会生活中大量以前不可能联网的设备也会进行联网工作，更加智能。汽车、井盖、电线杆、垃圾桶这些公共设施，以前管理起来非常难，也很难做到智能化。而5G可以让这些设备都成为智能设备。</li><li>重构安全<br>安全问题似乎并不是3GPP讨论的基本问题，但是它也应该成为5G的一个基本特点。<br>传统的互联网要解决的是信息速度、无障碍的传输，自由、开放、共享是互联网的基本精神，但是在5G基础上建立的是智能互联网。智能互联网不仅是要实现信息传输，还要建立起一个社会和生活的新机制与新体系。智能互联网的基本精神是安全、管理、高效、方便。安全是5G之后的智能互联网第一位的要求。假设5G建设起来却无法重新构建安全体系，那么会产生巨大的破坏力。<br>如果我们的无人驾驶系统很容易攻破，就会像电影上展现的那样，道路上汽车被黑客控制，智能健康系统被攻破，大量用户的健康信息被泄露，智慧家庭被攻破，家中安全根本无保障。这种情况不应该出现，出了问题也不是修修补补可以解决的。<br>在5G的网络构建中，在底层就应该解决安全问题，从网络建设之初，就应该加入安全机制，信息应该加密，网络并不应该是开放的，对于特殊的服务需要建立起专门的安全机制。网络不是完全中立、公平的。举一个简单的例子：网络保证上，普通用户上网，可能只有一套系统保证其网络畅通，用户可能会面临拥堵。但是智能交通体系，需要多套系统保证其安全运行，保证其网络品质，在网络出现拥堵时，必须保证智能交通体系的网络畅通。而这个体系也不是一般终端可以接入实现管理与控制的。<h2 id="5G应用场景定义了三大方向"><a href="#5G应用场景定义了三大方向" class="headerlink" title="5G应用场景定义了三大方向"></a>5G应用场景定义了三大方向</h2></li><li>eMBB（enhanced Mobile Broadband，移动宽带增强）<br>峰值数据率：最高数据传输速度达到20 Gbps用户体验数据率：拥挤地区传输速度达到100Mbps能量效益：装置收发数据所需功耗能效比较IMT-A提升100倍频谱效率：每无线带宽和每网络单元数据吞吐量3~4倍于4G网络区域流量容纳：区域内总流量密度每平方米10Mbps</li><li>MMTC（Massive Machine Type Communications，大规模物联网）<br>连接密度：每单位地区可连接设备数量每平方公里100万台<br>mMTC又包括eMTC（enhanced Machine<br>Type Communications，增强型物联网）和NB－IoT（Narrow Band<br>Internet of Things，窄带物联网</li><li>URLLC（Ultra-Reliable Low-Latency Communications，超高可靠超低时延通信）<br>低时延：数据包传输时延1毫秒移动性：切换和保证通讯质量极速达到500 km/h<h2 id="5G的关键技术"><a href="#5G的关键技术" class="headerlink" title="5G的关键技术"></a>5G的关键技术</h2>5G作为新一代的移动通信技术，它的网络结构、网络能力和要求都与过去有很大不同，有大量技术被整合在其中。其核心技术简述如下：</li><li>基于OFDM优化的波形和多址接入<br>5G采用基于OFDM化的波形和多址接入技术，因为OFDM技术被当今的 4G LTE 和 Wi-Fi 系统广泛采用，因其可扩展至大带宽应用，而具有高频谱效率和较低的数据复杂性，能够很好地满足 5G 要求。OFDM 技术家族可实现多种增强功能，例如通过加窗或滤波增强频率本地化、在不同用户与服务间提高多路传输效率，以及创建单载波OFDM波形，实现高能效上行链路传输。</li><li>实现可扩展的OFDM间隔参数配置<br>通过OFDM子载波之间的15kHz间隔（固定的OFDM参数配置），LTE最高可支持20 MHz的载波带宽。为了支持更丰富的频谱类型/带（为了连接尽可能丰富的设备，5G将利用所有能利用的频谱，如毫米微波、非授权频段）和部署方式。5G NR将引入可扩展的OFDM间隔参数配置。这一点至关重要，因为当FFT（Fast Fourier Transform，快速傅里叶变换）为更大带宽扩展尺寸时，必须保证不会增加处理的复杂性。而为了支持多种部署模式的不同信道宽度， 5G NR必须适应同一部署下不同的参数配置，在统一的框架下提高多路传输效率。另外，5G NR也能跨参数实现载波聚合，比如聚合毫米波和6GHz以下频段的载波。</li><li>OFDM加窗提高多路传输效率<br>5G将被应用于大规模物联网，这意味着会有数十亿设备在相互连接，5G势必要提高多路传输的效率，以应对大规模物联网的挑战。为了相邻频带不相互干扰，频带内和频带外信号辐射必须尽可能小。OFDM能实现波形后处理（post-processing），如时域加窗或频域滤波，来提升频率局域化。</li><li>灵活的框架设计<br>设计5G NR的同时，采用灵活的5G网络架构，进一步提高5G服务多路传输的效率。这种灵活性既体现在频域，更体现在时域上，5G NR的框架能充分满足5G的不同服务和应用场景。这包括可扩展的时间间隔（STTI，Scalable<br>Transmission Time Interval ），自包含集成子帧（Self-contained integrated subframe）。</li><li>先进的新型无线技术<br>5G演进的同时，LTE本身也还在不断进化（比如最近实现的千兆级4G+），5G不可避免地要利用目前用在4G LTE上的先进技术，如载波聚合、MIMO、非共享频谱等。这包括众多成熟的通信技术：<br>大规模MIMO：从2×2提高到了目前4×4<br>MIMO。更多的天线也意味着占用更多的空间，要在空间有限的设备中容纳进更多天线显然不现实，只能在基站端叠加更多MIMO。从目前的理论来看，5G NR 可以在基站端使用最多256根天线，而通过天线的二维排布，可以实现3D波束成型，从而提高信道容量和覆盖。<br>毫米波：全新5G技术正首次将频率大于24GHz以上频段（通常称为毫米波）应用于移动宽带通信。大量可用的高频段频谱可提供极致数据传输速度和容量，这将重塑移动体验。但毫米波的利用并非易事，使用毫米波频段传输更容易造成路径受阻与损耗（信号衍射能力有限）。通常情况下，毫米波频段传输的信号甚至无法穿透墙体，此外，它还面临着波形和能量消耗等问题。<br>频谱共享：用共享频谱和非授权频谱，可将5G扩展到多个维度，实现更大容量、使用更多频谱、支持新的部署场景。这不仅将使拥有授权频谱的移动运营商受益，而且会为没有授权频谱的厂商创造机会，如有线运营商、企业和物联网垂直行业，使他们能够充分利用5G NR技术。5G NR原生地支持所有频谱类型，并通过前向兼容灵活地利用全新的频谱共享模式。<br>先进的信道编码设计：目前LTE网络的编码还不足以应对未来的数据传输需求，因此迫切需要一种更高效的信道编码设计，以提高数据传输速率，并利用更大的编码信息块契合移动宽带流量配置，同时，还要继续提高现有信道编码技术（如LTE Turbo）的性能极限。 LDPC的传输效率远超LTE<br>Turbo，且易平行化的解码设计，能以低复杂度和低时延，扩展达到更高的传输速率。</li><li>超密集异构网络<br>5G网络是一个超复杂的网络，在2G时代，几万个基站就可以做全国的网络覆盖，但是到了4G中国的网络超过500万个。而5G需要做到每平方公里支持100万个设备，这个网络必须非常密集，需要大量的小基站来进行支撑。同样一个网络中，不同的终端需要不同的速率、功耗，也会使用不同的频率，对于QoS的要求也不同。这样的情况下，网络很容易造成相互之间的干扰。5G网络需要采用一系列措施来保障系统性能：不同业务在网络中的实现、各种节点间的协调方案、网络的选择以及节能配置方法等。<br>在超密集网络中，密集地部署使得小区边界数量剧增，小区形状也不规则，用户可能会频繁复杂地切换。为了满足移动性需求，这就需要新的切换算法。<br>总之，一个复杂的、密集的、异构的、大容量的、多用户的网络，需要平衡、保持稳定、减少干扰，这需要不断完善算法来解决这些问题。</li><li>网络的自组织<br>自组织的网络是5G的重要技术，这就是网络部署阶段的自规划和自配置；网络维护阶段的自优化和自愈合。自配置即新增网络节点的配置可实现即插即用，具有低成本、安装简易等优点。自规划的目的是动态进行网络规划并执行，同时满足系统的容量扩展、业务监测或优化结果等方面的需求。自愈合指系统能自动检测问题、定位问题和排除故障，大大减少维护成本并避免对网络质量和用户体验的影响。<br>SON技术应用于移动通信网络时，其优势体现在网络效率和维护方面，同时减少了运营商的支出和运营成本投入。由于现有的 SON 技术都是从各自网络的角度出发， 自部署、自配置、自优化和自愈合等操作具有独立性和封闭性，在多网络之间缺乏协作。</li><li>网络切片<br>就是把运营商的物理网络切分成多个虚拟网络，每个网络适应不同的服务需求，这可以通过时延、带宽、安全性、可靠性来划分不同的网络，以适应不同的场景。通过网络切片技术在一个独立的物理网络上切分出多个逻辑网络，从而避免了为每一个服务建设一个专用的物理网络，这样可以大大节省部署的成本。<br>在同一个5G网络上，通过技术电信运营商会把网络切片为智能交通、无人机、智慧医疗、智能家居以及工业控制等多个不同的网络，将其开放给不同的运营者，这样一个切片的网络在带宽、可靠性能力上也有不同的保证，计费体系、管理体系也不同。在切片的网络中，各个业务提供商，不是如4G一样，都使用一样的网络、一样的服务。很多能力变得不可控。5G切片网络，可以向用户提供不一样的网络、不同的管理、不同的服务、不同的计费，让业务提供者更好地使用5G网络。</li><li>内容分发网络<br>在5G网络中，会存在大量复杂业务，尤其是一些音频、视频业务大量出现，某些业务会出现瞬时爆炸性的增长，这会影响用户的体验与感受。这就需要对网络进行改造，让网络适应内容爆发性增长的需要。<br>内容分发网络是在传统网络中添加新的层次，即智能虚拟网络。CDN 系统综合考虑各节点连接状态、负载情况以及用户距离等信息，通过将相关内容分发至靠近用户的CDN代理服务器上、实现用户就近获取所需的信息，使得网络拥塞状况得以缓解，缩短响应时间，提高响应速度。<br>源服务器只需要将内容发给各个代理服务器，便于用户从就近的带宽充足的代理服务器上获取内容，降低网络时延并提高用户体验。CDN技术的优势正是为用户快速地提供信息服务，同时有助于解决网络拥塞问题。CDN技术成为5G必备的关键技术之一 。</li><li>设备到设备通信<br>这是一种基于蜂窝系统的近距离数据直接传输技术。设备到设备通信（D2D）会话的数据直接在终端之间进行传输，不需要通过基站转发，而相关的控制信令，如会话的建立、维持、无线资源分配以及计费、 鉴权、识别、移动性管理等仍由蜂窝网络负责。蜂窝网络引入D2D通信，可以减轻基站负担，降低端到端的传输时延，提升频谱效率，降低终端发射功率。当无线通信基础设施损坏，或者在无线网络的覆盖盲区，终端可借助D2D实现端到端通信甚至接入蜂窝网络。在 5G 网络中，既可以在授权频段部署D2D通信，也可在非授权频段部署。</li><li>边缘计算<br>在靠近物或数据源头的一侧，采用网络、计算、存储、应用核心能力为一体的开放平台，就近提供最近端服务。其应用程序在边缘侧发起，产生更快的网络服务响应，满足行业在实时业务、应用智能、安全与隐私保护等方面的基本需求。5G要实现低时延，如果数据都是要到云端和服务器中进行计算机和存储，再把指令发给终端，就无法实现低时延。边缘计算是要在基站上即建立计算和存储能力，在最短时间完成计算，发出指令。</li><li>软件定义网络和网络虚拟化<br>SDN架构的核心特点是开放性、灵活性和可编程性。它主要分为三层：基础设施层位于网络最底层，包括大量基础网络设备，该层根据控制层下发的规则处理和转发数据；中间层为控制层，该层主要负责对数据转发面的资源进行编排，控制网络拓扑、收集全局状态信息等；最上层为应用层，该层包括大量的应用服务，通过开放的北向API对网络资源进行调用。NFV作为一种新型的网络架构与构建技术， 其倡导的控制与数据分离、软件化、虚拟化思想，为突破现有网络的困境带来了希望。<br>5G是一个复杂的体系，在5G基础上建立的网络，不仅要提升网络速度，同时还提出了更多的要求。未来5G网络中的终端也不仅是手机，而是有汽车、无人驾驶飞机、家电、公共服务设备等多种设备。4G改变生活，5G改变社会。5G将会是社会进步、产业推动、经济发展的重要推进器</li></ul><h2 id="5G组网"><a href="#5G组网" class="headerlink" title="5G组网"></a>5G组网</h2><p>实现5G的应用，首先需要建设和部署5G网络，5G网络的部署主要需要两个部分：无线接入网（Radio Access Network，RAN）和核心网（Core Network）。无线接入网主要由基站组成，为用户提供无线接入功能。核心网则主要为用户提供互联网接入服务和相应的管理功能等。由于部署新的网络投资巨大且要分别部署这两部分，所以3GPP（3rd Generation Partnership Project，一个标准化组织）分为了两种方式进行部署SA（Standalone，独立组网）和NSA（Non－Standalone，非独立组网）。独立组网指的是新建一个现有的网络，包括新基站、回程链路以及核心网，非独立组网指的是使用现有的4G基础设施，进行5G网络的部署。<br><img src="/images/15.png"><br>在2016年6月制定的标准中，3GPP共列举了Option1、Option2 、Option 3／3a、Option 4／4a、Option 5、Option 6、Option 7／7a、Option 8／8a等8种5G架构选项。其中，Option1、Option 2、Option5和Option 6属于独立组网方式，其余属于非独立组网方式。<br>在2017年3月发布的版本中，优选了（并同时增加了2个子选项3x和7x）Option 2、Option 3／3a／3x、Option 4／4a、Option 5、Option 7／7a／7x等5种5G架构选项。独立组网方式还剩下Option2和Option 5两个选项。下边分别说明各个方式怎么进行网络部署。+5</p><ul><li><p>Option 1和Option 2<br><img src="/images/16.png"><br>选项1是4G网络目前的部署方式，由4G的核心网和基站组成。实线叫做用户面，代表传输的数据，虚线叫做控制面，代表传输管理和调度数据的命令。选项2属于5G独立组网，使用5G的基站和5G的核心网，服务质量更好，但成本也很高。</p></li><li><p>Option 3<br><img src="/images/17.png"><br>选项3主要使用的是4G的核心网络，分为主站和从站，与核心网进行控制面命令传输的基站为主站。由于传统的4G基站处理数据的能力有限，需要对基站进行硬件升级改造，变成增强型4G基站，该基站为主站，新部署的5G基站作为从站进行使用。<br>同时，由于部分4G基站时间较久，运营商不愿意花资金进行基站改造，所以就想了另外两种办法，选项3a和选项3x。选项3a就是5G的用户面数据直接传输到4G核心网。而选项3x是将用户面数据分为两个部分，将4G基站不能传输的部分数据使用5G基站进行传输，而剩下的数据仍然使用4G基站进行传输，两者的控制面命令仍然由4G基站进行传输。</p></li><li><p>Option 4<br><img src="/images/18.png"><br>选项4与选项3的不同之处就在于，选项4的4G基站和5G基站共用的是5G核心网，5G基站作为主站，4G基站作为从站。由于5G基站具有4G基站的功能，所以选项4中4G基站的用户面和控制面分别通过5G基站传输到5G核心网中，而选项4a中，4G基站的用户面直接连接到5G核心网，控制面仍然从5G基站传输到5G核心网。</p></li><li><p>Option 5和Option 6<br><img src="/images/19.png"><br>选项5可以理解为先部署5G的核心网，并在5G核心网中实现4G核心网的功能，先使用增强型4G基站，随后再逐步部署5G基站。选项6是先部署5G基站，采用4G核心网。但此选项会限制5G系统的部分功能，如网络切片，所以选项6已经被舍弃。</p></li><li><p>Option 7<br><img src="/images/20.png"><br>选项7和选项3类似，唯一的区别是将选项3中的4G核心网变成了5G核心网，传输方式是一样的。</p></li><li><p>Option 8<br><img src="/images/21.png"><br>选项8和8a使用的是4G核心网，运用5G基站将控制面命令和用户面数据传输至4G核心网中，由于需要对4G核心网进行升级改造，成本更高，改造更加复杂，所以这个选项在2017年3月发布的版本中被舍弃，这里不做更多的介绍。<br>2017年12月，5G的非独立组网（NSA）标准第一个版本正式冻结。2018年6月，5G的独立组网（NA）已经实现了部分功能冻结，预计第三季度实现整体标准的冻结。然而，目前现存的版本更多的侧重于移动带宽和高可靠低时延应用，5G更多的应用场景和标准还未被定义出来，预计2019年底5G的标准会被全面制定出来。为了避免短期内的高投入，各运营商会根据自己的实际情况选择不同的部署方式。</p><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2></li><li><p>3GPP<br><img src="/images/22.png"><br>5G标准制定分为两个阶段。第一阶段是R15标准，第二阶段是R16标准。为了充分利用现有网络设备并降低网络部署成本，R15版本分为早期版本（非独立组网NSA，在2018年3月已被冻结），主要版本（独立组网SA，已于2018年9月冻结）和延迟版本（原定于2018年12月冻结，现在推迟到2019年3月），所以之前所说的冻结只有R15 、NAS和AS。满足国际电信联盟所有要求的R16标准估计将在2020年3月前冻结。虽然5G技术标准尚未完全完成，但积极的运营商已经可以使用现有技术。该标准将部署在早期的5G网络中，以抓住市场机遇。<br>2017年12月发布了基于NSA（non-standalone，非独立组网）架构的5G Release15早期版本。非独立组网标准是基于NSA架构的5G网络，由于其5G空口载波仅承载用户数据，系统级的业务控制仍需依赖4G网络，这种方式可被视为在现有4G网络上增加新型载波进行扩容。由于依赖4G系统的核心网与控制面，NSA架构将无法充分发挥5G系统低时延的技术特点，也无法通过网络切片、移动边缘计算等特性实现对多样化业务需求的灵活支持。<br>美国圣地亚哥时间2018年6月13日20:18（北京时间2018年6月14日11:18），3GPP全会（TSG#80）批准了第五代移动通信技术标准（5G NR）独立组网功能冻结，标志着首个真正完整意义的国际5G标准正式出炉。<br>此次SA标准冻结不仅使5G NR具备了独立部署的能力，也带来全新的端到端新架构，赋能企业级客户和垂直行业的智慧化发展，为运营商和产业合作伙伴带来新的商业模式。<br>本次发布的5G Release15完整版本SA是采用崭新设计思路的全新架构，在引入全新网元与接口的同时，还将大规模采用网络虚拟化、软件定义网络等新技术。5G独立组网可以降低对现有4G网络的依赖性，更好地支持5G大带宽、低时延和大连接等各类业务，并可根据场景提供定制化服务，满足各类用户的业务需求，大力提升客户体验。<br>SA独立组网版本发布，意味着基于独立组网架构的5G系统能真正全面实现5G的技术指标和承诺，并为移动通信产业界创造出更新更多的发展机会。</p></li><li><p>标准文档简介<br>TS 38.201<br>标题名称：Physical layer; General description<br>主要内容：</p></li></ul><p>1.物理层主要文档简介（TS<br>38.200系列）<br>2.在哪寻找相应的信息</p><p>TS 38.202<br>标题名称：Physical layer services provided by<br>the physical layer<br>主要内容：<br>1.物理层提供的功能和服务<br>2. UE物理层模型（各个传输信道具体的处理模型）<br>3.物理层信道和SRS的并行传输等<br>4.物理层提供的测量</p><p>TS 38.211<br>标题名称：Physical channels and modulation<br>主要内容：<br>1.帧结构：帧，子帧，时隙<br>2.物理资源：天线端口，时频资源格，RB，RE，载波带宽<br>3.通用函数：各种调制方式、序列产生方式，OFDM时域信号<br>4.物理层上行信道/信号：PUSCH加扰、调制、层映射、预编码、资源映射等；PUCCH Format0-4序列产生、加扰、调制、预编码和映射；PRACH序列产生和资源映射DM-RS、PT-RS和SRS信号产生和映射等<br>5.物理层下行信道/信号：PDSCH加扰、调制、层映射、天线端口映射、资源映射等PDCCH CCE，加扰、调制和资源映射等PBCH加扰、调制和资源映射等DM-RS，PT-RS，CSI-RS参考信号的产生和映射SSS和PSS同步信号的产生和映射SSS、PSS和PBCH等信号在时域和频域的位置</p><p>TS 38.212<br>标题名称：Multiplexing and channel coding<br>主要内容：<br>1.传输信道与物理信道的映射关系<br>2.信道编码相关流程：（具体编码算法）CRC计算，分段和CRC添加信道编码方式：Polar码，LDPC码，小码块的编码速率匹配等<br>3.上行传输信道和控制信息上行共享信道（UL-SCH）:CRC添加，LDPC<br>Graph选择，分段与CRC添加，信道编码，速率匹配，码块拼接，数据和控制信心的复用 上行控制信息（PUCCH上传输）：UCI信息产生，分段和CRC添加，信道编码，速率匹配，码块拼接，复用 上行控制信息（PUSCH上传输）：UCI信息产生，分段和CRC添加，信道编码，速率匹配，码块拼接，复用<br>4.下行传输信道和控制信息广播信道：序列产生，加扰，CRC添加，信道编码，速率匹配 下行共享信道和寻呼信道：CRC添加，LDPC Graph选择，分段和CRC添加，信道编码，速率匹配，码块拼接 下行控制信道：DCI格式（DCI Format0_0, DCI Format0_1, DCI<br>Format1_0, DCI Format1_1, DCIFormat2_0, DCI Format2_1, DCI Format2_2, DCI<br>Format0_3），CRC添加，信道编码，速率匹配</p><p>TS 38.213<br>标题名称：Physical layer procedures for control<br>主要内容：<br>1.同步流程：小区搜索，传输时间调整，辅小区激活时间<br>2.无限链路监视：UE需要监视主小区的链路质量<br>3.链路重配流程<br>4.上行功率控制<br>5.随机接入流程<br>6. UE报告控制信息流程：HARQ-ACK码本判决（CBG-based HARQ-ACK，Type-1 HARQ-ACK，Type-2 HARQ-ACK）在上行控制信道上报告UCI在上行共享信道上报告UCI 7.UE接收控制信息流程<br>8. UE-Group公共信令：时隙配置信令，非连续传输指示，SRS切换<br>9.带宽相关操作<br>10. UE监视Type0-PDCCH公共搜索区域</p><p>TS 38.214<br>标题名称：Physical layer procedures for data 主要内容：<br>1.下行功率控制<br>2.物理下行共享信道相关流程UE接收PDSCH信号流程：传输方案，资源分配（时域，频域），调制方式确定和对应码率等（TBS表格），资源映射（RB层次和RE层次），UE接收下行参考信号 UE发送CSI信道流程：CSI信息框架，报告配置，基于PUCCH和PUSCH传输 UE<br>PDSCH处理时间<br>3. 物理上行共享信道相关流程UE发送PUSCH信号流程：传输方案（基于码本传输，非码本传输），资源分配（时域，频域），变换预编码（Transform precoding），调制方式确定和对应码率等 UE参考信号流程：DM-RS，PT-RS，SRS UE<br>PUSCH 调频流程UE PUSCH准备过程时间</p><p>TS 38.215<br>标题名称：Physical layer measurements<br>主要内容：<br>1.UE测量能力<br>2.NR-RAN测量能力<br>8 5G创新<br>3GPP将“5G”视为是一个重大的改革，要具备五大创新！</p><h2 id="mmWave"><a href="#mmWave" class="headerlink" title="mmWave"></a>mmWave</h2><p>提到网络速率，必定和频率、波长、以及光速三者有关，长期以来，我们主要使用中频到超高频来实行手机通讯的。经常所说的CDMA 800、GSM 850，就是工作频段800MHz和850MHz的意思。就目前来说，现如今的4G LTE属于超高频和特高频。并且我们国家主要使用超高频。依照第一个图的公式，频率越高，速度越快，车道（频段）也就越宽。<br>也就意味着波长越小，5G的第一个创新技术就来了，率先使用目前波段较小的mmWave（毫米波），就目前的动态来看，毫米波段中28GHz频段和60GHz频段比较有希望使用在5G的两个频段中，使用毫米波频段，频谱带宽比较前代要宽了10倍，传输速率自然也得到大幅度提升。</p><ul><li><p>Massive MIMO<br>MIMO的英文全称是Multiple-Input Multiple-Output，意为“多进多出”，说白了就是基站的天线变多了，并且手机的接受能力也变强了，源头上多根天线发送，接收对象多根天线接受。<br>为了进一步提升5G网络的覆盖面积，5G网络将原有的宏基站改为了微基站，换句话说，之前的信号向中央空调，一个温暖一群人，而现在则是按照小群体分配一个“小功率”空调，不仅辐射被大幅度降低，覆盖面积也好，速率也变得越快。</p></li><li><p> Beam Management<br>Beam Management意为波束赋形，也是第五代移动通讯技术的一大创新，它主要是改变了信号的发射形式进行的改变。说到基站发射信号的形式，有些类似于灯泡发光，它是360度向四面八方发射的，对于光而言，要想照亮某个区域或某处物体，大部分散发出去的光都浪费了。<br>而波束赋形就比较厉害了，它是一种基于天线阵列的信号预处理技术，通过调整天线阵列中的每个阵元的加权系数产生具有指向性的波束，通俗的将，它可以改变信号的发射轨迹，实现“点对点”有针对的信号传播。</p></li><li><p>LDPC/Polar<br>前面说过，3GPP对应想要涉及的领域，定义了5G的三大场景：eMBB、mMTC和URLLC。不知道朋友们记不记得2017年11月下旬，华为公司主推的Polar Code（极化码）方案拿下5G，作为控制信道的编码方案，这个方案便是3PGG制定的三个场景之一的eMBB场景，而高通主导的LDPC码作为数据信道的编码方案。根据华为的实际测试来看，Polar码可以同时满足超高速率、低时延、大连接场景的需求，并且能够使蜂窝网络的频谱提升10%左右，与毫米波结合可以达到27Gbps的速率。对于eMBB场景来说，有了华为这位主力，外加高通的扶持，相信能够将无线通讯技术提升到新的高度。</p></li><li><p>AS Layer<br>AS Layer是相比较4G网络的一种新型的架构模式，主要是以正交频分多任务（OFDM）为基础的弹性参数物理层（PHY,Layer 1），它可以最多包含5个次载波。该架构可以同时回应更快速的数据与响应速度。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;5G&quot;&gt;&lt;a href=&quot;#5G&quot; class=&quot;headerlink&quot; title=&quot;5G&quot;&gt;&lt;/a&gt;5G&lt;/h2&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;5G网</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>4G网络构架</title>
    <link href="http://example.com/2021/03/05/4G%E7%BD%91%E7%BB%9C%E6%9E%84%E6%9E%B6/"/>
    <id>http://example.com/2021/03/05/4G%E7%BD%91%E7%BB%9C%E6%9E%84%E6%9E%B6/</id>
    <published>2021-03-05T12:37:02.000Z</published>
    <updated>2021-03-05T14:40:49.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4G"><a href="#4G" class="headerlink" title="4G"></a>4G</h2><p>是第四代移动通信技术，该技术包括TD-LTE和FDD-LTE两种制式，严格意义上来讲LTE只是3.9G，只有升级版的LTE Advanced才满足国际电信联盟对4G的要求。<br>4G是集3G与WLAN于一体，并能够快速传输数据、高质量、音频、视频和图像等。4G能够以100Mbps以上的速度下载，比目前的家用宽带ADSL（4兆）快25倍，并能够满足几乎所有用户对于无线服务的要求。</p><ul><li>LTE网络结构如下：<br><img src="/images/6.png"><br>整个LTE网络从接入网和核心网方面分为E-UTRAN和EPC两个大的部分。相比于3G技术，对应于3G技术中的UTRAN和EPC部分。</li></ul><h2 id="E-UTRAN（Evolved-Universal-Terrestrial-RadioAccess-Network）"><a href="#E-UTRAN（Evolved-Universal-Terrestrial-RadioAccess-Network）" class="headerlink" title="E-UTRAN（Evolved Universal Terrestrial RadioAccess Network）"></a>E-UTRAN（Evolved Universal Terrestrial RadioAccess Network）</h2><p>E-UTRAN在系统性能和能力方面的研究目标主要是以下几点：</p><ul><li><p>更高的空中接口峰值速率以及频谱效率。</p></li><li><p>在E-UTRAN中，eNodeB之间底层采用IP传输，在逻辑上通过X2 接口互相连接，即形成Mesh 型网络。这样的网络结构设计主要用于支持UE 在整个网络内的移动性，保证用户的无缝切换。而每个eNodeB 通过S1 接口和移动性管理实体/接入网关（MobilityManagement Entity (MME)/Serving Gateway(S-GW)）连接，一个eNodeB 可以和多个MME/S-GW 互连，反之亦然。</p></li><li><p>在E-UTRAN网络中，由于没有了RNC，整个E-UTRAN的空中接口协议结构与原来的UTRAN相比有了较大的不同，特别是不同功能实体的位置出现了很多的变化。原来由RNC承担的功能被分散到了eNodeB和MME/S-GW上。</p></li></ul><h2 id="EPC（EvolvedPacket-Core）"><a href="#EPC（EvolvedPacket-Core）" class="headerlink" title="EPC（EvolvedPacket Core）"></a>EPC（EvolvedPacket Core）</h2><p>EPC 核心网主要由移动性管理设备（MME）、服务网关（S-GW）、分组数据网关（P-GW）、存储用户签约信息的HSS、策略控制单元（PCRF）等组成，其中S-GW 和P-GW可以合设，也可以分设。EPC 核心网架构秉承了控制与承载分离的理念，将分组域中SGSN 的移动性管理、信令控制功能和媒体转发功能分离出来，分别由两个网元来完成，其中，MME 负责移动性管理、信令处理等功能，S-GW 负责媒体流处理及转发等功能，P-GW 则仍承担GGSN 的职能。LTE 无线系统中取消了RNC 网元，将其功能分别移至基站eNodeB 和核心网网元，eNodeB 将直接通过S1 接口与MME、S-GW 互通，简化了无线系统的结构。</p><h2 id="4G网络架构的变化"><a href="#4G网络架构的变化" class="headerlink" title="4G网络架构的变化"></a>4G网络架构的变化</h2><ul><li><p>实现了控制与承载的分离，MME负责移动性管理、信令处理等功能，S-GW负责媒体流处理及转发等功能。</p></li><li><p>核心网取消了CS（电路域），全IP的EPC（Evolved Packet Core，移动核心网演进）支持各类技术统一接入，实现固网和移动融合（FMC），灵活支持VoIP及基于IMS多媒体业务，实现了网络全IP化。</p></li><li><p>取消了RNC，原来RNC功能被分散到了eNodeB和网关（GW）中，eNodeB直接接入EPC，LTE网络结构更加扁平化，降低了用户可感知的时延，大幅提升用户的移动通信体验。</p></li><li><p>接口连接方面，引入S1-Flex和X2接口，移动承载需实现多点到多点的连接，X2是相邻eNB间的分布式接口，主要用于用户移动性管理；S1-Flex是从eNB到EPC的动态接口，主要用于提高网络冗余性以及实现负载均衡。</p></li><li><p>传输带宽方面：较3G基站的传输带宽需求增加10倍，初期200-300Mb/s，后期将达到1Gb/s。</p></li><li><p>3G与4G系统参数的比较<br><img src="/images/7.png"></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4G&quot;&gt;&lt;a href=&quot;#4G&quot; class=&quot;headerlink&quot; title=&quot;4G&quot;&gt;&lt;/a&gt;4G&lt;/h2&gt;&lt;p&gt;是第四代移动通信技术，该技术包括TD-LTE和FDD-LTE两种制式，严格意义上来讲LTE只是3.9G，只有升级版的LTE Advanced</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>什么是3G?</title>
    <link href="http://example.com/2021/03/05/%E4%BB%80%E4%B9%88%E6%98%AF3G/"/>
    <id>http://example.com/2021/03/05/%E4%BB%80%E4%B9%88%E6%98%AF3G/</id>
    <published>2021-03-05T12:24:04.000Z</published>
    <updated>2021-03-05T14:40:39.971Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3G（3rd-Generation）"><a href="#3G（3rd-Generation）" class="headerlink" title="3G（3rd Generation）"></a>3G（3rd Generation）</h2><p>代表着第三代移动通信技术。手机自问世至今，经历了第一代模拟制动通信技术。手机自问世至今，经历了第一代模拟制式手机（1G）和第二代GSM、TDMA等数字手机（2G），而当前通信运营商和终端产品制造商倡导的3G是指将无线通信与国际互联网等多媒体通信结合的新一代移动通信系统。它能够处理图像、语音、视频流等多种媒体形式，提供包括网页浏览、电话会议、电子商务等多种信息服务。为手机融入多媒体元素提供强大的支持。</p><p>第三代通信网络的主要目标定位于实时视频、高速多媒体和移动Internet访问业务。利用先进的空中接口技术、核心包分组技术，再加上对频谱的高效利用，是可以实现上述业务的。虽然高速数据传输能力是第三代无线网络的关键特征之一，但其真正优势是扩大高质量话音业务容量。当前第二代网络所能支持的高质量话音业务容量的拓展速度已不能满足客户对其需求的增长。高数据容量可使移动用户与Internet更加贴近。除了增加一定的技术复杂性外，基于ATM或 IP技术的网络通信将会极大降低话音、数据业务的成本。</p><ul><li><p>3G技术的标准：国际电信联盟（ITU）早在2000年5月即确定了W-CDMA、CDMA2000和TD-SCDMA三个主流3G标准。</p></li><li><p>W-CDMA：即Wideband CDMA，意为宽频分码多重存取，是由GSM网发展出来的3G技术规范，其支持者主要是以GSM系统为主的欧洲厂商，包括欧美的爱立信、诺基亚、朗讯、北电以及日本的NTT、富士通、夏普等厂商。这套系统能够架设在现有的GSM网络上，对于系统提供商而言可以较方便地过渡，而GSM系统相当普及的亚洲对这套新技术的接受度会比较高。因此，W-CDMA具有先天的市场优势。目前W-CDMA手机已有多种产品面世，但国内还没有完善的3G网络可以应用。</p></li><li><p>CDMA2000：由美国高通北美公司为主导提出，摩托罗拉、朗讯和韩国三星都已参与，韩国现在成为该标准的主导者。这套标准是从窄频CDMA2000 1X数字标准衍生出来的，可以从原有的CDMA2000 1X结构直接升级到CDMA2000 3X（3G），建设成本低廉。但目前使用CDMA的地区只有日、韩和北美，中国联通正是也应用了该模式过渡的，CDMA2000的支持者不如W-CDMA 多。不过CDMA2000的研发技求却是目前各标准中进度最快的，许多3G手机也已率先面世。</p></li><li><p>TD-SCDMA：全称Time Division-Synchronous CDMA，该标准是由我国大唐电信公司提出的3G标准。该标准将智能无线、同步CDMA和软件无线电等当今国际领先技术融于其中。由于中国国内庞大的市场，该标准受到各大主要电信设备厂商的重视，全球一半以上的设备厂商都宣布可以支持TD-SCDMA标准，对于中国通信事业实为一大机遇。</p></li></ul><p>由于3G商用需要相当浩大的工程，所牵扯的层面多且复杂，要从目前的2G迈向3G不可能一下就衔接得上，因而2.5G的手机就应运而生，目前已经进行商业应用的2.5G移动通信技术可以认为是从2G迈向3G的衔接性技术，同时也就衍生了HSCSD、WAP、EDGE、蓝牙(Bluetoot)、EPOC等技术都是2.5G技术。</p><ul><li>2.5G包括了CDMA2000 1X和GPRS，在国内也就有了中国联通和中国移动两大对立阵营，可以说两个阵营都为各自的标准逐步迈向3G。</li></ul><p> - CDMA：Code　Division　Multiple　Access（码分多址访问技术）。也就是说，由于通信运营商为了向尽可能多的用户提供服务，因此就需要让多个用户共用同一个频带。此时，就可以通过利用叫做伪随机噪声码(Pseudo　noise　Code，PN码)的特殊符号，来区分每位用户的通话信道。CDMA2000  1x被称为2.5代移动通信技术，可以认为是CDMA2000 3X（3G）的过渡阶段。</p><ul><li><p>CDMA2000  3x与CDMA2000  1x的主要区别在于应用了多路载波技术，通过采用三载波使带宽提高，而CDMA2000  1x只使用1个频带，因而就叫“1x”。目前中国联通正在采用这一方案向3G过渡，并已建成了CDMA2000  1x网络。</p></li><li><p>GPRS：General　Packet　Radio　Service（通用分组无线服务）的简称，它是在现有的GSM网络基础上开通的一种新型的高速分组数据传输技术。相对于原来的GSM以拨号接入的电路交换数据传送方式，GPRS是分组交换技术，具有“永远在线”、“自如切换”、“高速传输”等优点。它能使移动数据通讯服务更强大，更便捷。目前中国移动正在采用这一方案向3G过渡，并已将原有的GSM网络升级为GPRS网络，通过其完善的GSM网为用户提供全方位的GPRS服务。</p></li><li><p>EDGE：Enhanced Data rate for GSM Evolution（增强数据速率的GSM演进）的简称，是速度更高的GPRS后续技术。EDGE完全以目前的GSM标准为架构，不但能够将GPRS的功能发挥到极限，还可以透过目前的无线网络提供宽频多媒体的服务。可以应用在诸如无线多媒体、电子邮件、网络信息娱乐以及电视会议上。让我们初步体验3G技术的魅力。目前诺基亚6220及后继机型率先支持此项技术。</p></li></ul><p>纵观多项新技术，预示着3G时代就要到来，层出不穷的新技术不断被应用，将来的移动通信工具将不仅我们带来通信方便，更为我们带来了无限精彩的移动多媒体世界。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;3G（3rd-Generation）&quot;&gt;&lt;a href=&quot;#3G（3rd-Generation）&quot; class=&quot;headerlink&quot; title=&quot;3G（3rd Generation）&quot;&gt;&lt;/a&gt;3G（3rd Generation）&lt;/h2&gt;&lt;p&gt;代表着第三代</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>2G的完整形式</title>
    <link href="http://example.com/2021/03/05/2G%E7%9A%84%E5%AE%8C%E6%95%B4%E5%BD%A2%E5%BC%8F/"/>
    <id>http://example.com/2021/03/05/2G%E7%9A%84%E5%AE%8C%E6%95%B4%E5%BD%A2%E5%BC%8F/</id>
    <published>2021-03-05T12:10:06.000Z</published>
    <updated>2021-03-05T14:39:55.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2G（Second-Generation"><a href="#2G（Second-Generation" class="headerlink" title="2G（Second Generation)"></a>2G（Second Generation)</h1><p>2G is an abbreviation of the “Second-Generation Cellular Network”.</p><p>2G是“第二代蜂窝网络”的缩写 。</p><p>In 1991, 2G cellular networks were commercially introduced on the GSM standard in Finland by Radiolinja, which at the present, is a component of Elisa Oyj.</p><p>1991年，Radiolinja依照芬兰的GSM标准在商业上引入了2G蜂窝网络，该网络目前是Elisa Oyj的组成部分。</p><p>Three most significant advantages of 2G networks over their antecedents were that:</p><p>2G网络相对于其前身的三个最重要的优势是：</p><p>The conversations happen on phone were using digital technology converted into codes.</p><p>在电话上进行的对话是使用转换为密码的数字技术进行的。</p><p>Extensively highly well-organized use of the radio frequency spectrum allowing a large number of users as per frequency band.</p><p>无线电频谱的广泛高度组织化使用，每个频带允许大量用户。</p><p>Initiation of data services for mobile at the beginning with SMS text messages.</p><p>首先使用SMS文本消息启动移动数据服务。</p><p>2G technologies allowed a variety of networks to offer and make available services such as text messages, picture messages, and MMS (multimedia messages). The entire text messages sent over 2G are using digital technology converted into codes, enabling the transmission of data in such a way that only the anticipated or deliberate receiver can collect and read it.</p><p>2G技术允许各种网络提供和提供服务，例如文本消息，图片消息和MMS(多媒体消息)。 通过2G发送的整个文本消息都使用了转换为代码的数字技术，从而以只有预期或有意的接收者才能收集和读取数据的方式进行数据传输。</p><p>After 2G was introduced; the earlier mobile wireless network systems were retroactively dubbed 1G. At the same time as radio signals on 1G networks are based on analog, radio signals on 2G networks are based on digital. Both the systems of 1G and 2G make use of digital signaling to connect the radio towers (which listen to the devices) to the rest of the mobile system.</p><p>引入2G之后； 早期的移动无线网络系统被追溯称为1G。 同时1G网络上的无线电信号基于模拟，而2G网络上的无线电信号基于数字。 1G和2G系统都利用数字信令将无线电塔(监听设备)连接到移动系统的其余部分。</p><p>2G puts forward a theoretical highest transfer speed of 40 kbit/s with General Packet Radio Service (GPRS). There is a theoretical highest transfer speed of 384 kbit/s with EDGE (Enhanced Data Rates for GSM Evolution).</p><p>2G提出了使用通用分组无线服务(GPRS)的理论上最高的40 kbit / s传输速度。 使用EDGE(GSM演进的增强数据速率)时，理论上的最高传输速度为384 kbit / s。</p><p>The most widespread 2G technology was the time division multiple access (TDMA)-based GSM, formerly from Europe but used in the majority of the world externally out of North America. By 2010, more than 60 GSM operators were also using CDMA2000 in the 450 MHz frequency band (CDMA450).</p><p>最为广泛的2G技术是基于时分多址(TDMA)的GSM，其原产于欧洲，但在北美以外的世界大部分地区使用。 到2010年，超过60个GSM运营商也在450 MHz频带(CDMA450)中使用CDMA2000。</p><h1 id="2G演进-2G-Evolution"><a href="#2G演进-2G-Evolution" class="headerlink" title="2G演进 (2G Evolution)"></a>2G演进 (2G Evolution)</h1><ul><li>2.5G (GPRS)</li></ul><p>2.5G (“second and a half generation”) is used to illustrate 2G-systems that have put into operation a packet-switched domain as well as to the circuit-switched domain.</p><p>It doesn’t essentially make available more rapid service for the reason that the packaging of timeslots is used for circuit-switched data services (HSCSD) as well.</p><ul><li>2.75G (EDGE)</li></ul><p>With the launch of 8PSK encoding, GPRS networks evolved and developed to EDGE networks.</p><p>Enhanced Data rates for GSM Evolution (EDGE), Enhanced GPRS (EGPRS), or IMT Single Carrier (IMT-SC) is a backward-compatible digital mobile phone technology that enables enhanced data transmission rates, as an expansion on top of customary GSM.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2G（Second-Generation&quot;&gt;&lt;a href=&quot;#2G（Second-Generation&quot; class=&quot;headerlink&quot; title=&quot;2G（Second Generation)&quot;&gt;&lt;/a&gt;2G（Second Generation)&lt;/h1</summary>
      
    
    
    
    <category term="科技" scheme="http://example.com/categories/%E7%A7%91%E6%8A%80/"/>
    
    
    <category term="知识" scheme="http://example.com/tags/%E7%9F%A5%E8%AF%86/"/>
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>教你访问steam社区</title>
    <link href="http://example.com/2020/03/04/%E6%95%99%E4%BD%A0%E8%AE%BF%E9%97%AEsteam%E7%A4%BE%E5%8C%BA/"/>
    <id>http://example.com/2020/03/04/%E6%95%99%E4%BD%A0%E8%AE%BF%E9%97%AEsteam%E7%A4%BE%E5%8C%BA/</id>
    <published>2020-03-04T02:55:30.000Z</published>
    <updated>2021-03-05T14:42:53.853Z</updated>
    
    <content type="html"><![CDATA[<p>如果你的电脑里还没有一个像样的网络代理但想访问steam社区，那不妨试试这个软件。</p><h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><p>解压下载好的压缩包，打开里面的exe文件即可使用，无需安装。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>链接：<a href="https://pan.baidu.com/s/1mygj-J9reQI0qIKoIDeoYA">https://pan.baidu.com/s/1mygj-J9reQI0qIKoIDeoYA</a><br>提取码：7oxn</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如果你的电脑里还没有一个像样的网络代理但想访问steam社区，那不妨试试这个软件。&lt;/p&gt;
&lt;h1 id=&quot;安装教程&quot;&gt;&lt;a href=&quot;#安装教程&quot; class=&quot;headerlink&quot; title=&quot;安装教程&quot;&gt;&lt;/a&gt;安装教程&lt;/h1&gt;&lt;p&gt;解压下载好的压缩包，打开里</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="搞机" scheme="http://example.com/tags/%E6%90%9E%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>电脑chrome用网络代理</title>
    <link href="http://example.com/2020/03/03/%E7%94%B5%E8%84%91chrome%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2020/03/03/%E7%94%B5%E8%84%91chrome%E7%94%A8%E7%BD%91%E7%BB%9C%E4%BB%A3%E7%90%86/</id>
    <published>2020-03-03T12:03:18.000Z</published>
    <updated>2021-03-05T14:43:08.862Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用效果"><a href="#使用效果" class="headerlink" title="使用效果"></a>使用效果</h1><p>这是一个梯子各位都懂，不过它的速度不是很理想，对于像我这种没钱买机场的人来说可以将就用一下。</p><h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><p>它也是一个chrome的扩展程序，所以安装方法可以参考我的上一篇博客“教你使用插件访问chrome扩展商店”。</p><h1 id="使用教程"><a href="#使用教程" class="headerlink" title="使用教程"></a>使用教程</h1><p>安装完成以后只要在chrome的右上角点击扩展程序图标即可使用。</p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>链接：<a href="https://pan.baidu.com/s/1F-1c3JIVluiB_8Z4jyQK2w">https://pan.baidu.com/s/1F-1c3JIVluiB_8Z4jyQK2w</a><br>提取码：v675</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用效果&quot;&gt;&lt;a href=&quot;#使用效果&quot; class=&quot;headerlink&quot; title=&quot;使用效果&quot;&gt;&lt;/a&gt;使用效果&lt;/h1&gt;&lt;p&gt;这是一个梯子各位都懂，不过它的速度不是很理想，对于像我这种没钱买机场的人来说可以将就用一下。&lt;/p&gt;
&lt;h1 id=&quot;安装教</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="搞机" scheme="http://example.com/tags/%E6%90%9E%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>教你使用插件访问chrome商店</title>
    <link href="http://example.com/2020/03/03/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E8%AE%BF%E9%97%AEchrome%E5%95%86%E5%BA%97/"/>
    <id>http://example.com/2020/03/03/%E6%95%99%E4%BD%A0%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E8%AE%BF%E9%97%AEchrome%E5%95%86%E5%BA%97/</id>
    <published>2020-03-03T11:56:16.000Z</published>
    <updated>2021-03-05T14:42:17.460Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h1><ul><li>将下载好的文件解压</li><li>打开chrome浏览器，点击右上角的“自定义及控制（三个点）”，找到“更多工具”，点击“扩展工具”<br><img src="/images/2.png"></li><li>打开右上角的“开发者模式”<br><img src="/images/3.png"></li><li>将第一步解压好的文件拖到浏览器空白处<br><img src="/images/4.png"> </li><li>然后就会出现下面这个页面，点击第二个“chrome商店”<br><img src="/images/5.png"></li><li>完成<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1>链接：<a href="https://pan.baidu.com/s/1N6EOHNZ1aaUUNVOuk_cjpg">https://pan.baidu.com/s/1N6EOHNZ1aaUUNVOuk_cjpg</a><br>提取码：0azl<h1 id="扩展程序推荐"><a href="#扩展程序推荐" class="headerlink" title="扩展程序推荐"></a>扩展程序推荐</h1></li><li>Infinity新标签页（一个看起来很舒服的标签页）</li><li>购物党自动比价工具（使用某宝和某东的时候能用到的查看历史价格工具）</li><li>AdGuard广告拦截器（顾名思义）</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装教程&quot;&gt;&lt;a href=&quot;#安装教程&quot; class=&quot;headerlink&quot; title=&quot;安装教程&quot;&gt;&lt;/a&gt;安装教程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将下载好的文件解压&lt;/li&gt;
&lt;li&gt;打开chrome浏览器，点击右上角的“自定义及控制（三个点）”，找到“更多</summary>
      
    
    
    
    <category term="技术" scheme="http://example.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="分享" scheme="http://example.com/tags/%E5%88%86%E4%BA%AB/"/>
    
    <category term="搞机" scheme="http://example.com/tags/%E6%90%9E%E6%9C%BA/"/>
    
  </entry>
  
</feed>
